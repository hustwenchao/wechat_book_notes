---
doc_type: weread-highlights-reviews
bookId: "603196"
author: 弗兰纳根
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/196/603196/t7_603196.jpg
reviewCount: 4
noteCount: 148
isbn: 9787111376613
category: 计算机-编程设计
lastReadDate: 2020-04-14
---
# 元数据
> [!abstract] JavaScript权威指南（原书第6版）
> - ![ JavaScript权威指南（原书第6版）|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/196/603196/t7_603196.jpg)
> - 书名： JavaScript权威指南（原书第6版）
> - 作者： 弗兰纳根
> - 简介： "本书要讲述的内容涵盖JavaScript语言本身，以及Web浏览器所实现的JavaScript API。本书更适合有一定编程经验的人阅读。对于那些希望学习JavaScript和已经开始使用JavaScript的程序员来说，如果想让自己对JavaScript语言和Web平台的理解和掌握再上一个台阶，本书最适合不过了。"
> - 出版时间 2012-04-25 00:00:00
> - ISBN： 9787111376613
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社

# 高亮划线

## 第3章 类型、值和变量


- 📌 JavaScript还定义了另一种特殊对象——函数。函数是具有与它相关联的可执行代码的对象，通过调用函数来运行可执行代码，并返回运算结果。和数组一样，函数的行为特征和其他对象都不一样。JavaScript为使用函数定义了专用语法。对于JavaScript函数来讲，最重要的是，它们都是真值，并且JavaScript可以将它们当做普通对象来对待。第8章会专门讲述函数。 ^603196-16-1405-1588
    - ⏱ 2020-04-02 17:18:04 

- 📌 JavaScript变量是无类型的(untyped)，变量可以被赋予任何类型的值，同样一个变量也可以重新赋予不同类型的值。使用var关键字来声明（declare）变量。JavaScript采用词法作用域（lexical scoping）。不在任何函数内声明的变量称做全局变量（global variable），它在JavaScript程序中的任何地方都是可见的。在函数内声明的变量具有函数作用域（function scope），并且只在函数内可见。变量声明和作用域将会在3.9节和3.10节详细讲解。 ^603196-16-3037-3287
    - ⏱ 2020-04-02 17:20:36 
## 3.1 数字


- 📌 和其他编程语言[插图]不同，JavaScript不区分整数值和浮点数值。 ^603196-17-429-535
    - ⏱ 2020-04-02 17:21:11 

- 📌 按照JavaScript中的数字格式，能够表示的整数范围是从-9007199254740992～9007199254740992 (即-253～253)，包含边界值。如果使用了超过此范围的整数，则无法保证低位数字的精度。然而需要注意的是，JavaScript中实际的操作（比如数组索引，以及第4章讲到的位操作符）则是基于32位整数。 ^603196-17-862-1082
    - ⏱ 2020-04-02 17:21:28 

- 📌 JavaScript中的算术运算在溢出（overflow）、下溢（underflow）或被零整除时不会报错。 ^603196-17-3867-3921
    - ⏱ 2020-04-02 17:29:25 

- 📌 下溢（underflow）是当运算结果无限接近于零并比JavaScript能表示的最小值还小的时候发生的一种情形。这种情况下，JavaScript将会返回0。当一个负数发生下溢时，JavaScript返回一个特殊的值“负零”。这个值（负零）几乎和正常的零完全一样，JavaScript程序员很少用到负零。 ^603196-17-4153-4305
    - ⏱ 2020-04-02 17:31:02 

- 📌 但有一个例外，零除以零是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值，用NaN表示。无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作数一起使用时都将返回NaN。 ^603196-17-4392-4504
    - ⏱ 2020-04-02 17:31:53 

- 📌 JavaScript中的非数字值有一点特殊：它和任何值都不相等，包括自身。也就是说，没办法通过x==NaN来判断变量x是否是NaN。相反，应当使用x!=x来判断，当且仅当x为NaN的时候，表达式的结果才为true。函数isNaN（）的作用与此类似，如果参数是NaN或者是一个非数字值（比如字符串和对象），则返回true。JavaScript中有一个类似的函数isFinite（），在参数不是NaN、Infinity或-Infinity的时候返回true。 ^603196-17-5276-5503
    - ⏱ 2020-04-02 17:33:23 

- 📌 负零值同样有些特殊，它和正零值是相等的（甚至使用JavaScript的严格相等测试来判断）。这意味着这两个值几乎一模一样，除了作为除数之外： ^603196-17-5532-5602
    - ⏱ 2020-04-02 17:34:01 

- 📌 在这之前你可能更愿意使用大整数进行重要的金融计算，例如，要使用整数“分”而不要使用小数“元”进行基于货币单位的运算。 ^603196-17-6970-7028
    - ⏱ 2020-04-02 17:35:22 
## 3.2 文本


- 📌 JavaScript采用UTF-16编码的Unicode字符集，JavaScript字符串是由一组无符号的16位值组成的序列 ^603196-18-793-855
    - ⏱ 2020-04-02 17:36:47 

- 📌 在客户端JavaScript程序设计中，JavaScript代码会夹杂HTML代码的字符串，HTML代码也会夹杂JavaScript代码。和JavaScript一样，HTML也使用单引号或者双引号来定界字符串，因此，当JavaScript代码和HTML代码混杂在一起的时候，最好在JavaScript和HTML代码中各自使用独立的引号风格。例如，在JavaScript表达式中使用单引号表示字符串“Thank you”，而在HTML事件处理程序属性中则使用双引号表示字符串： ^603196-18-2347-2584
    - ⏱ 2020-04-02 17:38:44 

- 📌 3.2.4 模式匹配 ^603196-18-5378-5388
    - ⏱ 2020-04-02 17:40:22 

- 📌 [插图] ^603196-18-6063-6064
    - ⏱ 2020-04-02 17:45:04 
## 5.7 其他语句类型


- 📌 在严格模式中（参照5.7.3节）是禁止使用with语句的，并且在非严格模式里也是不推荐使用with语句的，尽可能避免使用with语句。那些使用with语句的JavaScript代码非常难于优化，并且同没有使用with语句的代码相比，它运行得更慢。 ^603196-48-915-1038
    - ⏱ 2020-04-04 23:21:01 

- 📌 with语句提供了一种读取o的属性的快捷方式，但它并不能创建o的属性。 ^603196-48-1912-1947
    - ⏱ 2020-04-04 23:21:59 
## 第6章 对象


- 📌 对象的原型（prototype）指向另外一个对象，本对象的属性继承自它的原型对象。 ^603196-50-2139-2180
    - ⏱ 2020-04-04 23:25:49 

- 📌 对象的类（class）是一个标识对象类型的字符串。 ^603196-50-2211-2236
    - ⏱ 2020-04-04 23:25:53 

- 📌 对象的扩展标记（extensible flag）指明了（在ECMAScript 5中）是否可以向该对象添加新属性。 ^603196-50-2267-2324
    - ⏱ 2020-04-04 23:25:57 

- 📌 内置对象（native object） ^603196-50-2496-2515
    - ⏱ 2020-04-04 23:26:29 

- 📌 宿主对象（host object） ^603196-50-2592-2609
    - ⏱ 2020-04-04 23:26:34 

- 📌 自定义对象（user-defined object ^603196-50-2767-2787
    - ⏱ 2020-04-04 23:26:38 

- 📌 自有属性（own property） ^603196-50-2848-2866
    - ⏱ 2020-04-04 23:26:42 

- 📌 继承属性（inherited property） ^603196-50-2910-2934
    - ⏱ 2020-04-04 23:26:46 
## 6.1 创建对象


- 📌 属性名可以是JavaScript标识符也可以是字符串直接量（包括空字符串） ^603196-51-688-725
    - ⏱ 2020-04-04 23:28:05 

- 📌 所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过JavaScript代码Object.prototype获得对原型对象的引用。通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。因此，同使用{}创建对象一样，通过new Object（）创建的对象也继承自Object.prototype。同样，通过new Array（）创建的对象的原型就是Array.prototype，通过new Date（）创建的对象的原型就是Date.prototype。 ^603196-51-2461-2708
    - ⏱ 2020-04-04 23:29:11 

- 📌 ECMAScript 5定义了一个名为Object.create（）的方法， ^603196-51-3232-3270
    - ⏱ 2020-04-04 23:30:31 

- 📌 inherit（）函数的其中一个用途就是防止库函数无意间（非恶意地）修改那些不受你控制的对象。不是将对象直接作为参数传入函数，而是将它的继承对象传入函数。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象： ^603196-51-5066-5209
    - ⏱ 2020-04-04 23:31:59 
## 6.2 属性的查询和设置


- 📌 第一种语法使用点运算符和一个标识符，这和C和Java中访问一个结构体或对象的静态字段非常类似。第二种语法使用方括号和一个字符串，看起来更像数组，只是这个数组元素是通过字符串索引而不是数字索引。这种数组就是我们所说的关联数组（associative array），也称做散列、映射或字典（dictionary）。JavaScript对象都是关联数组，本节将讨论它的重要性。 ^603196-52-1524-1709
    - ⏱ 2020-04-04 23:32:56 

- 📌 由于JavaScript是弱类型语言 ^603196-52-1984-2002
    - ⏱ 2020-04-04 23:33:03 

- 📌 查询一个不存在的属性并不会报错，如果在对象o自身的属性或继承的属性中均未找到属性x，属性访问表达式o.x返回undefined。回想一下我们的book对象有属性“sub-title”，而没有属性“subtitle”： ^603196-52-5519-5627
    - ⏱ 2020-04-04 23:34:54 

- 📌 这是一个历史遗留问题，这个bug在ECMAScript 5的严格模式中已经修复。在严格模式中，任何失败的属性设置操作都会抛出一个类型错误异常。 ^603196-52-6568-6639
    - ⏱ 2020-04-04 23:35:48 

- 📌 o中的属性p是只读的：不能给只读属性重新赋值（defineProperty（）方法中有一个例外，可以对可配置的只读属性重新赋值）。 ^603196-52-6750-6816
    - ⏱ 2020-04-04 23:36:10 

- 📌 o中的属性p是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性。 ^603196-52-6847-6887
    - ⏱ 2020-04-04 23:36:15 

- 📌 o中不存在自有属性p：o没有使用setter方法继承属性p，并且o的可扩展性（extensibleattribute）是false（参照6.8.3节）。如果o中不存在p，而且没有setter方法可供调用，则p一定会添加至o中。但如果o不是可扩展的，那么在o中不能定义新属性 ^603196-52-6918-7056
    - ⏱ 2020-04-04 23:36:22 
## 6.4 检测属性


- 📌 in运算符的左侧是属性名（字符串），右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回true： ^603196-54-582-635
    - ⏱ 2020-04-04 23:40:43 

- 📌 对象的hasOwnProperty（）方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回false： ^603196-54-826-883
    - ⏱ 2020-04-04 23:40:51 

- 📌 某些内置属性是不可枚举的。通常由JavaScript代码创建的属性都是可枚举的，除非在ECMAScript 5中使用一个特殊的方法来改变属性的可枚举性，随后会提到： ^603196-54-1230-1312
    - ⏱ 2020-04-04 23:41:06 

- 📌 注意，上述代码中使用的是“!==”运算符，而不是“!=”。“!==”可以区分undefined和null。有时则不必作这种区分： ^603196-54-2286-2350
    - ⏱ 2020-04-04 23:42:02 
## 6.5 枚举属性


- 📌 我们还会经常遍历对象的属性 ^603196-55-432-445
    - ⏱ 2020-04-04 23:42:47 

- 📌 这些新添加的方法是不能定义为不可枚举的，因此它们都可以在for/in循环中枚举出来。 ^603196-55-998-1040
    - ⏱ 2020-04-04 23:43:48 
## 6.6 属性getter和setter


- 📌 对象属性是由名字、值和一组特性（attribute）构成的。 ^603196-56-445-475
    - ⏱ 2020-04-04 23:45:14 

- 📌 和数据属性不同，存取器属性不具有可写性（writable attribute） ^603196-56-928-967
    - ⏱ 2020-04-04 23:45:33 

- 📌 定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法： ^603196-56-1115-1146
    - ⏱ 2020-04-04 23:45:52 
## 6.7 属性的特性


- 📌 通过调用Object.getOwnPropertyDescriptor（）可以获得某个对象特定属性的属性描述符： ^603196-57-1327-1383
    - ⏱ 2020-04-07 12:52:22 
## 6.9 序列化对象


- 📌 JSON的语法是JavaScript语法的子集，它并不能表示JavaScript里的所有值。支持对象、数组、字符串、无穷大数字、true、false和null，并且它们可以序列化和还原。NaN、Infinity和-Infinity序列化的结果是null，日期对象序列化的结果是ISO格式的日期字符串（参照Date.toJSON（）函数），但JSON.parse（）依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error对象和undefined值不能序列化和还原。JSON.stringify（）只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。JSON.stringify（）和JSON. parse（）都可以接收第二个可选参数，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。第三部分有关于这些函数的详细文档。 ^603196-59-1097-1507
    - ⏱ 2020-04-07 13:01:05 
## 第7章 数组


- 📌 JavaScript数组的索引是基于零的32位数值：第一个元素的索引为0，最大可能的索引为4294967294（232-2），数组最大能容纳4294967295个元素。 ^603196-61-569-680
    - ⏱ 2020-04-08 00:30:46 

- 📌 每个JavaScript数组都有一个length属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length比所有元素的索引要大。 ^603196-61-792-864
    - ⏱ 2020-04-08 00:31:06 
## 7.2 数组元素的读和写


- 📌 请记住，数组是对象的特殊形式。使用方括号访问数组元素就像用方括号访问对象的属性一样。JavaScript将指定的数字索引值转换成字符串——索引值1变成“1”——然后将其作为属性名来使用。关于索引值从数字转换为字符串没什么特别之处：对常规对象也可以这么做 ^603196-63-800-926
    - ⏱ 2020-04-08 00:32:41 

- 📌 所有的索引都是属性名，但只有在0～232-2之间的整数属性名才是索引。 ^603196-63-1257-1319
    - ⏱ 2020-04-08 00:33:14 

- 📌 当使用的一个浮点数和一个整数相等时情况也是一样的： ^603196-63-1530-1555
    - ⏱ 2020-04-08 00:33:42 
## 7.3 稀疏数组


- 📌 够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高 ^603196-64-778-806
    - ⏱ 2020-04-08 00:34:39 

- 📌 需要注意的是，当省略数组直接量中的值时（使用连续的逗号，比如[1,,3]），这时所得到的数组也是稀疏数组，省略掉的值是不存在的： ^603196-64-1278-1342
    - ⏱ 2020-04-08 00:35:18 
## 7.4 数组长度


- 📌 第二个特殊的行为就是设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除： ^603196-65-867-929
    - ⏱ 2020-04-08 00:36:27 

- 📌 类似地，如果让一个数组元素不能配置，就不能删除它。如果不能删除它，length属性不能设置为小于不可配置元素的索引值。 ^603196-65-1572-1631
    - ⏱ 2020-04-08 00:36:56 
## 7.5 数组元素的添加和删除


- 📌 unshift（） ^603196-66-832-841
    - ⏱ 2020-04-08 00:38:05 

- 📌 可以像删除对象属性一样使用delete运算符来删除数组元素： ^603196-66-913-943
    - ⏱ 2020-04-08 00:38:24 

- 📌 上面我们看到，也可以简单地设置length属性为一个新的期望长度来删除数组尾部的元素。数组有pop（）方法（它和push（）一起使用），后者一次使减少长度1并返回被删除元素的值。还有一个shift（）方法（它和unshift（）一起使用），从数组头部删除一个元素。和delete不同的是shift（）方法将所有元素下移到比当前索引低1的地方。7.8节和第三部分涵盖pop（）和shift（）的内容。 ^603196-66-1275-1474
    - ⏱ 2020-04-08 00:38:54 

- 📌 最后，splice（）是一个通用的方法来插入、删除或替换数组元素。它会根据需要修改length属性并移动元素到更高或较低的索引处 ^603196-66-1503-1567
    - ⏱ 2020-04-08 00:39:03 
## 7.6 数组遍历


- 📌 ECMAScript规范允许for/in循环以不同的顺序遍历对象的属性。通常数组元素的遍历实现是升序的，但不能保证一定是这样的。特别地，如果数组同时拥有对象属性和数组元素，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。如何处理这个问题的实现各不相同，如果算法依赖于遍历的顺序，那么最好不要使用for/in而用常规的for循环。 ^603196-67-2082-2249
    - ⏱ 2020-04-08 00:41:07 
## 7.8 数组方法


- 📌 join（） ^603196-69-614-620
    - ⏱ 2020-04-08 00:42:57 

- 📌 reverse（） ^603196-69-1158-1168
    - ⏱ 2020-04-08 00:43:18 

- 📌 sort（） ^603196-69-1446-1452
    - ⏱ 2020-04-08 00:43:23 

- 📌 Array.sort（）方法将数组中的元素排序并返回排序后的数组 ^603196-69-1481-1513
    - ⏱ 2020-04-08 00:43:30 

- 📌 splice（） ^603196-69-3694-3702
    - ⏱ 2020-04-08 00:44:40 

- 📌 splice（）会修改调用的数组 ^603196-69-3785-3801
    - ⏱ 2020-04-08 00:45:29 

- 📌 splice（）能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。 ^603196-69-3874-3913
    - ⏱ 2020-04-08 00:45:33 

- 📌 splice（）返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。 ^603196-69-4047-4089
    - ⏱ 2020-04-08 00:46:56 

- 📌 splice（）的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入。 ^603196-69-4281-4351
    - ⏱ 2020-04-08 00:47:13 

- 📌 splice（）会插入数组本身而非数组的元素。 ^603196-69-4554-4577
    - ⏱ 2020-04-08 00:47:37 

- 📌 push（）和pop（） ^603196-69-4635-4647
    - ⏱ 2020-04-08 00:47:45 

- 📌 unshift（）在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。shift（）删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。例如： ^603196-69-5433-5549
    - ⏱ 2020-04-08 00:48:13 

- 📌 参数是一次性插入的（就像splice（）方法）而非一次一个地插入。 ^603196-69-5994-6027
    - ⏱ 2020-04-08 00:48:42 
## 7.9 ECMAScript5中的数组方法


- 📌 forEach（） ^603196-70-937-947
    - ⏱ 2020-04-08 10:15:07 

- 📌 map（） ^603196-70-1955-1961
    - ⏱ 2020-04-08 10:15:11 

- 📌 every（）和some（） ^603196-70-3064-3078
    - ⏱ 2020-04-08 10:15:16 

- 📌 reduce（）和reduceRight（） ^603196-70-4021-4043
    - ⏱ 2020-04-08 10:15:20 

- 📌 indexOf（）和lastIndexOf（） ^603196-70-6464-6488
    - ⏱ 2020-04-08 10:15:27 
## 7.11 类数组对象


- 📌 这些特性让JavaScript数组和常规的对象有明显的区别。但是它们不是定义数组的本质特性。一种常常完全合理的看法把拥有一个数值length属性和对应非负整数属性的对象看做一种类型的数组。实践中这些“类数组”对象实际上偶尔出现，虽然不能在它们之上直接调用数组方法或者期望length属性有什么特殊的行为，但是仍然可以用针对真正数组遍历的代码来遍历它们。结论就是很多数组算法针对类数组对象工作得很好，就像针对真正的数组一样。如果算法把数组看成只读的或者如果它们至少保持数组长度不变，也尤其是这种情况。 ^603196-72-697-975
    - ⏱ 2020-04-08 13:07:48 
## 7.12 作为数组的字符串


- 📌 当然，针对字符串的typeof操作符仍然返回“string”，但是如果给Array.isArray（）传递字符串，它将返回false。 ^603196-73-646-713
    - ⏱ 2020-04-08 13:09:49 
## 第8章 函数


- 📌 数的定义会包括一个称为形参（parameter）的标识符列表，这些参数在函数体中像局部变量一样工作。函数调用会为形参提供实参的值[插图] ^603196-74-539-604
    - ⏱ 2020-04-08 13:10:18 

- 📌 如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文（context） ^603196-74-838-907
    - ⏱ 2020-04-08 13:10:48 

- 📌 这意味着JavaScript函数构成了一个闭包（closure），它给JavaScript带来了非常强劲的编程能力。 ^603196-74-1197-1255
    - ⏱ 2020-04-08 13:11:10 
## 8.1 函数定义


- 📌 任何合法的JavaScript标识符都可以用做一个函数的名称。命名时要尽量选择描述性强而又简洁的函数名。在这两者之间做到恰到好处是一门艺术，需要丰富的经验。精心挑选的函数名可以极大地改善代码的可读性（从而也提高了可维护性）。 ^603196-75-2138-2250
    - ⏱ 2020-04-08 13:12:03 

- 📌 动词或以动词为前缀的词组 ^603196-75-2292-2304
    - ⏱ 2020-04-08 13:12:10 

- 📌 这种函数名通常以一条下划线为前缀。 ^603196-75-2449-2466
    - ⏱ 2020-04-08 13:12:21 

- 📌 通常为那些经常调用的函数指定短名称，比如客户端JavaScript框架jQuery（第19章会详细讲述）就将最常用的方法重命名为$（） ^603196-75-2518-2585
    - ⏱ 2020-04-08 13:12:44 

- 📌 undefined ^603196-75-3013-3014
    - ⏱ 2020-04-08 13:13:24 
## 8.2 函数调用


- 📌 构成函数主体的JavaScript代码在定义之时并不会执行 ^603196-76-418-447
    - ⏱ 2020-04-08 13:14:01 

- 📌 当方法的返回值是一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（通常称为“链”或者“级联”）每次的调用结果都是另外一个表达式的组成部分 ^603196-76-3432-3505
    - ⏱ 2020-04-09 13:23:22 

- 📌 需要注意的是，this是一个关键字，不是变量，也不是属性名。JavaScript的语法不允许给this赋值。 ^603196-76-4173-4227
    - ⏱ 2020-04-09 13:23:52 

- 📌 方法call（）和apply（）可以用来间接地调用函数。 ^603196-76-6137-6165
    - ⏱ 2020-04-08 13:16:02 
## 8.3 函数的实参和形参


- 📌 函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象（参照7.11节），这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。 ^603196-77-2024-2112
    - ⏱ 2020-04-08 13:52:53 
## 8.5 作为命名空间的函数


- 📌 比如，假设你写了一段JavaScript模块代码，这段代码将要用在不同的JavaScript程序中（对于客户端JavaScript来讲通常是用在各种各样的网页中）。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量： ^603196-79-802-1029
    - ⏱ 2020-04-09 13:28:07 
## 8.6 闭包


- 📌 函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的 ^603196-80-470-511
    - ⏱ 2020-04-09 13:28:53 

- 📌 嵌套函数的词法作用域规则 ^603196-80-1140-1152
    - ⏱ 2020-04-09 13:29:32 

- 📌 如果你想搞清楚这个问题，你需要更深入地了解类似C语言这种更底层的编程语言，并了解基于栈的CPU架构：如果一个函数的局部变量定义在CPU的栈中，那么当函数返回时它们的确就不存在了。 ^603196-80-2660-2749
    - ⏱ 2020-04-09 13:32:48 
 
## 8.7 函数属性、方法和构造函数


- 📌 是函数是JavaScript中特殊的对象 ^603196-81-489-509
    - ⏱ 2020-04-09 13:38:48 

- 📌 函数的length属性是只读属性，它代表函数实参的数量 ^603196-81-791-818
    - ⏱ 2020-04-09 13:39:53 
## 第9章 类和模块


- 📌 类的实现是基于其原型继承机制的 ^603196-83-748-763
    - ⏱ 2020-04-07 16:42:52 

- 📌 如果两个对象继承自同一个原型，往往意味着（但不是绝对）它们是由同一个构造函数创建并初始化的。 ^603196-83-911-957
    - ⏱ 2020-04-09 13:46:33 

- 📌 JavaScript中类的一个重要特性是“动态可继承”（dynamically extendable） ^603196-83-1447-1498
    - ⏱ 2020-04-07 16:43:16 

- 📌 它弱化了对象的类型，强化了对象的功能 ^603196-83-1576-1594
    - ⏱ 2020-04-07 16:43:25 
## 9.2 类和构造函数


- 📌 构造函数的prototye属性被用做新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的成员。 ^603196-85-580-651
    - ⏱ 2020-04-09 13:48:50 
## 9.5 类和类型


- 📌 鸭式辩型，这种编程哲学更加关注对象可以完成什么工作 ^603196-88-819-844
    - ⏱ 2020-04-10 11:41:20 

- 📌 上文所描述的检测对象的类的各种技术多少都会有些问题 ^603196-88-5184-5209
    - ⏱ 2020-04-10 11:43:19 
## 9.9 模块


- 📌 一般来讲，模块是一个独立的JavaScript文件。模块文件可以包含一个类定义、一组相关的类、一个实用函数库或者是一些待执行的代码 ^603196-92-476-541
    - ⏱ 2020-04-10 11:53:59 

- 📌 但imports和exports的确是JavaScript保留的关键字，因此JavaScript的未来版本可能会支持 ^603196-92-777-835
    - ⏱ 2020-04-10 11:54:11 

- 📌 你会发现在JavaScript中实现一个模块代码并不困难 ^603196-92-1556-1584
    - ⏱ 2020-04-10 11:55:52 

- 📌 模块的实现往往需要一些额外的辅助函数和方法 ^603196-92-4040-4061
    - ⏱ 2020-04-10 13:04:09 

- 📌 因此应当根据所使用的框架和工具包来选择合适的模块创建和导出API的方式。 ^603196-92-7687-7723
    - ⏱ 2020-04-10 13:03:53 
## 第11章 JavaScript的子集和扩展


- 📌 由于Firefox是基于一个名叫Spidermonkey的JavaScript引擎 ^603196-97-999-1040
    - ⏱ 2020-04-10 13:08:23 
## 11.1 JavaScript的子集


- 📌 能在一个容器或“沙箱” ^603196-98-1923-1934
    - ⏱ 2020-04-10 13:11:22 

- 📌 eval（）和Function（）构造函数在任何安全子集里都是禁止使用的，因为它们可以执行任意代码，而且JavaScript无法对这些代码做静态分析。 ^603196-98-2268-2343
    - ⏱ 2020-04-10 13:11:38 

- 📌 禁止使用this关键字，因为函数（在非严格模式中）可以通过this访问全局对象。而沙箱系统的一个重要目的就是阻止对全局对象的访问。 ^603196-98-2374-2439
    - ⏱ 2020-04-10 13:11:42 

- 📌 禁止使用with语句，因为with语句增加了静态代码检查的难度。禁止使用某些全局变量。在客户端JavaScript中，浏览器窗口对象可以当做全局对 ^603196-98-2470-2543
    - ⏱ 2020-04-10 13:11:49 
## 11.2 常量和局部变量


- 📌 一直以来，JavaScript中的变量缺少块级作用域的支持被普遍认为是JavaScript的短板，JavaScript 1.7针对这个缺陷增加了关键字let。关键字const一直都是JavaScript的保留字（没有使用），因此现有的代码不必作任何改动就可以增加常量，关键字let并不是保留字，JavaScript1.7及以后的版本才能识别，需要手动加入版本号才可以。 ^603196-99-827-1011
    - ⏱ 2020-04-10 13:13:22 
## 11.3 解构赋值


- 📌 “解构赋值 ^603196-100-452-457
    - ⏱ 2020-04-10 13:16:45 
## 11.4 迭代


- 📌 但for/each并不是遍历对象的属性，而是遍历属性的值 ^603196-101-878-906
    - ⏱ 2020-04-10 13:18:31 

- 📌 使用数组时，for/each循环遍历循环的元素（而不是索引）。它通常按数值顺序枚举它们，但实际上这并不是标准化或必需的： ^603196-101-1111-1171
    - ⏱ 2020-04-10 13:18:48 

- 📌 JavaScript 1.7为for/in循环增加了更多通用的功能。JavaScript 1.7中的循环和Python的for/in循环非常类似，它可以遍历任何可迭代的（iterable）对象。为了便于理解，我们首先给出一些定义。 ^603196-101-1664-1779
    - ⏱ 2020-04-10 13:18:54 
## 第13章 Web浏览器中的JavaScript


- 📌 叫做文档（document） ^603196-109-710-724
    - ⏱ 2020-04-10 16:58:51 
## 13.1 客户端JavaScript


- 📌 Window对象是所有客户端JavaScript特性和API的主要接入点。 ^603196-110-448-485
    - ⏱ 2020-04-10 16:59:39 

- 📌 setTimeout（） ^603196-110-776-788
    - ⏱ 2020-04-07 15:53:00 

- 📌 每个Element对象都有style和className属性，允许脚本指定文档元素的CSS样式，或修改应用到元素上的CSS类名。设置这些CSS相关的属性会改变文档元素的呈现： ^603196-110-1787-1874
    - ⏱ 2020-04-10 17:06:29 

- 📌 Web文档里应当少量地使用JavaScript，因为JavaScript真正的角色是增强用户的浏览体验，使信息的获取和传递更容易。用户的体验不应依赖于JavaScript，但JavaScript可以增强体验，比如通过下面的方式：·创建动画和其他视觉效果，巧妙地引导和帮助用户进行页面导航。·对表格的列进行分组，让用户更容易找到所需要的。·隐藏某些内容，当用户“深入”到内容里时，再逐渐展示详细信息。 ^603196-110-4357-4646
    - ⏱ 2020-04-10 17:07:14 
## 13.2 在HTML里嵌入JavaScript


- 📌 有个编程哲学叫“unobtrusive JavaScript”[插图]，主张内容（HTML）和行为（JavaScript代码）应该尽量地保持分离。根据这个编程哲学，JavaScript最好通过<script>元素的src属性来嵌入HTML文档里。 ^603196-111-983-1326
    - ⏱ 2020-04-10 17:09:07 

- 📌 这里的onchange属性比较有意思。这个属性值里的JavaScript代码会在用户选择或取消选择复选框时执行 ^603196-111-7232-7287
    - ⏱ 2020-04-10 17:12:04 

- 📌 实际上，很多Web开发者认为使用HTML事件处理程序的属性是不好的习惯，他们更喜欢保持内容和行为的分离。 ^603196-111-7535-7587
    - ⏱ 2020-04-10 17:12:30 
## 13.3 JavaScript程序的执行


- 📌 客户端JavaScript程序没有严格的定义。我们可以说JavaScript程序是由Web页面中所包含的所有JavaScript代码（内联脚本、HTML事件处理程序和javascript: URL）和通过<script>标签的src属性引用的外部JavaScript代码组成。所有这些单独的代码共用同一个全局Window对象。这意味着它们都可以看到相同的Document对象，可以共享相同的全局函数和变量的集合：如果一个脚本定义了新的全局变量或函数，那么这个变量或函数会在脚本执行之后对任意JavaScript代码可见。 ^603196-112-442-708
    - ⏱ 2020-04-07 16:05:46 

- 📌 如果Web页面包含一个嵌入的窗体（通常使用<iframe>元素），嵌入文档中的JavaScript代码和被嵌入文档里的JavaScript代码会有不同的全局对象，它可以当做一个单独的JavaScript程序。但是，要记住，没有严格的关于JavaScript程序范围的定义。如果外面和里面的文档来自于同一个服务器，那么两个文档中的代码就可以进行交互，并且如果你愿意，就可以把它们当做是同一个程序的两个相互作用的部分。14.8.3节会详细介绍全局Window对象以及不同窗口和窗体之间的交互。 ^603196-112-737-987
    - ⏱ 2020-04-07 16:05:52 

- 📌 事件驱动阶段里发生的第一个事件是load事件，指示文档已经完全载入，并可以操作。 ^603196-112-1700-1740
    - ⏱ 2020-04-11 17:15:04 

- 📌 核心JavaScript和客户端JavaScript都有一个单线程执行模型。脚本和事件处理程序（无论如何）在同一个时间只能执行一个，没有并发性。 ^603196-112-2070-2142
    - ⏱ 2020-04-07 16:09:15 

- 📌 在撰写本书的时候，async和defer属性还没有广泛实现，它们只被一些优化建议所考虑。即便延迟和异步的脚本会同步执行，Web页面应该还可以正常工作。 ^603196-112-4275-4350
    - ⏱ 2020-04-07 16:11:01 

- 📌 有些事件的目标是文档元素，它们会经常往上传递给文档树，这个过程叫做“冒泡”。例如，如果用户在<button>元素上单击鼠标，单击事件就会在按钮上触发。如果注册在按钮上的函数没有处理（并且冒泡停止）该事件，事件会冒泡到按钮嵌套的容器元素，这样，任何注册在容器元素上的单击事件都会调用。 ^603196-112-6418-6565
    - ⏱ 2020-04-07 16:15:35 

- 📌 并且永远不需要在写JavaScript代码的时候担心锁、死锁和竞态条件（race condition） ^603196-112-8602-8653
    - ⏱ 2020-04-11 17:19:03 
## 13.6 安全性


- 📌 义强大的客户端API，启用强大的Web应用； ^603196-115-554-576
    - ⏱ 2020-04-11 17:21:35 

- 📌 阻止恶意代码读取或修改数据、盗取隐私、诈骗或浪费时间。 ^603196-115-607-634
    - ⏱ 2020-04-11 17:21:41 

- 📌 类似地，客户端JavaScript没有任何通用的网络能力。客户端JavaScript程序可以对HTTP协议编程（参见第18章）；并且HTML5有一个附属标准叫WebSockets，定义了一个类套接字的API，用于和指定的服务器通信。但是，这些API都不允许对于范围更广的网络进行直接访问。通用的Internet客户端和服务器不能同时使用客户端JavaScript来写￼。 ^603196-115-1255-1558
    - ⏱ 2020-04-11 17:22:30 
## 15.2 选取文档元素


- 📌 任何HTML元素可以有一个id属性，在文档中该值必须唯一，即同一个文档中的两个元素不能有相同的ID。可以用Document对象的getElementById（）方法选取一个基于唯一ID的元素。 ^603196-128-905-1001
    - ⏱ 2020-04-13 13:14:14 

- 📌 在低于IE 8版本的浏览器中，getElementById（）对匹配元素的ID不区分大小写，而且也返回匹配name属性的元素。 ^603196-128-2016-2079
    - ⏱ 2020-04-13 13:14:47 

- 📌 HTML元素的class属性值是一个以空格隔开的列表，可以为空或包含多个标识符。 ^603196-128-7165-7205
    - ⏱ 2020-04-13 13:15:27 

- 📌 class属性通常与CSS样式表一起使用，对某组内的所有元素应用相同的样式， ^603196-128-7324-7362
    - ⏱ 2020-04-13 13:15:42 
## 15.5 元素的内容


- 📌 读取Element的innerHTML属性作为字符串标记返回那个元素的内容。在元素上设置该属性调用了Web浏览器的解析器，用新字符串内容的解析展现形式替换元素当前内容。（不要管它的名字，除了在HTML元素上，innerHTML也可以在XML元素上使用。） ^603196-131-866-993
    - ⏱ 2020-04-13 13:21:37 

- 📌 Web浏览器很擅长解析HTML，通常设置innerHTML效率非常高，甚至在指定的值需要解析时效率也是相当不错。但注意，对innerHTML属性用“+=”操作符重复追加一小段文本通常效率低下，因为它既要序列化又要解析。 ^603196-131-1022-1131
    - ⏱ 2020-04-13 13:21:46 
## 16.3 脚本化内联样式


- 📌 但是style属性不同寻常：它的值不是字符串，而是一个CSSStyleDeclaration对象。 ^603196-140-505-554
    - ⏱ 2020-04-14 00:43:22 
## 16.4 查询计算出的样式


- 📌 getComputedStyle（） ^603196-141-3067-3085
    - ⏱ 2020-04-14 00:44:21 
# 读书笔记

## 3.1 数字

### 划线评论
- 📌 这些复杂运算通过作为Math对象的属性定义的函数和常量来实现：  ^2009032-7gjfbwpzo
    - 💭 JavaScript的Math库
    - ⏱ 2020-04-02 17:28:09

### 划线评论
- 📌 日期和时间  ^2009032-7gjfH3iSE
    - 💭 JavaScript的日期和时间接口
    - ⏱ 2020-04-02 17:35:55
   
## 8.6 闭包

### 划线评论
- 📌 但回想一下在3.10.3节中是如何定义作用域链的。我们将作用域链描述为一个对象列表，不是绑定的栈。每次调用JavaScript函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中。当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也没有其他引用指向这个绑定对象，它就会被当做垃圾回收掉。如果定义了嵌套的函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链指向一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来，那么它们也会和所指向的变量绑定对象一样当做垃圾回收。但是如果这个函数定义了嵌套的函数，并将它作为返回值返回或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套的函数。它就不会被当做垃圾回收，并且它所指向的变量绑定对象也不会被当做垃圾回收  ^2009032-7gtE1oYPS
    - 💭 闭包的关键点应该使用对象引用来理解，而不是使用基于栈的结构理解
    - ⏱ 2020-04-09 13:34:05
   
## 9.2 类和构造函数

### 划线评论
- 📌 [插图]  ^2009032-7gqOu3Aki
    - 💭 这个代码错了
    - ⏱ 2020-04-07 16:53:49
   
# 本书评论
