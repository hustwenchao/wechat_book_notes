---
doc_type: weread-highlights-reviews
bookId: "33692196"
author: Stanley B·Lippman Josée Lajoie Barbara E·Moo
cover: https://cdn.weread.qq.com/weread/cover/59/YueWen_33692196/t7_YueWen_33692196.jpg
reviewCount: 3
noteCount: 161
isbn: 9787121155352
category: 计算机-编程设计
lastReadDate: 2022-12-23
---
# 元数据
> [!abstract] C++ Primer（中文版）（第5版）
> - ![ C++ Primer（中文版）（第5版）|200](https://cdn.weread.qq.com/weread/cover/59/YueWen_33692196/t7_YueWen_33692196.jpg)
> - 书名： C++ Primer（中文版）（第5版）
> - 作者： Stanley B·Lippman Josée Lajoie Barbara E·Moo
> - 简介： 这本久负盛名的C++经典教程，时隔八年之久，终于迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——C++大师Stanley B. Lippman的丰富实践经验，C++标准委员会原负责人Josée Lajoie对C++标准的深入理解，以及C++先驱Barbara E. Moo在C++教学方面的真知灼见外，更是基于全新的C++11标准进行了全面而彻底的内容更新。非常难能可贵的是，书中所有示例均全部采用C++11标准改写，这在经典升级版中极其罕见——充分体现了C++语言的重大进展及其全面实践。书中丰富的教学辅助内容、醒目的知识点提示，以及精心组织的编程示范，让这本书在C++领域的权威地位更加不可动摇。无论是初学者入门，或是中高级程序员提升使用，本书均为不容置疑的首选。
> - 出版时间 2013-09-01 00:00:00
> - ISBN： 9787121155352
> - 分类： 计算机-编程设计
> - 出版社： 电子工业出版社

# 高亮划线

## 推荐序1


- 📌 原来版本中来不及引入的内容，以及语言机制中发现的一些缺陷，都在新版本中得以弥补和发展。比如新版标准中引入了无序容器，以弥补原版标准中对hash容器的缺漏；新版标准支持移动构造函数和移动赋值运算符，以减小特定场景下对象拷贝的性能开销。新版标准不仅在语法上增加了大量特性，而且在标准库里也引入大量设施，使得标准库对于C++语言的重要性远超从前。 ^33692196-5-492-662
    - ⏱ 2022-08-09 20:12:52 

- 📌 第5版则更加像一本学习教程，由浅入深，并结合大量代码实例来讲述C++语法和标准库 ^33692196-5-1301-1341
    - ⏱ 2022-08-09 20:13:22 

- 📌 像编译器一样来思考和理解C++语言，如果暂时做不到，也不要紧，当有了一定的编写程序经验以后，在“揣摩”编译器行为的过程中可逐渐掌握C++语法特性。 ^33692196-5-1491-1564
    - ⏱ 2022-08-09 20:13:43 
## 推荐序2


- 📌 一种优秀的编程语言，一定要对于计算这件事情实现一个完整和自洽的抽象。十几年来编程语言领域的竞争，除却实现质量之外，基本上是在比拼抽象的设计。而C语言之所以四十年长盛不衰，根本在于它对于现代计算机提供了一个底层的高级抽象：凡是比它低的抽象都过于简陋，凡是比它高的抽象都可以用C语言构造出来。C++成功的根本原因，恰恰是因为它虽然试图提供一些高级的抽象机制，但是其根基与C在同一层面。正因为如此，每当你需要走下去直接与硬件对话时，C++成为C之外唯一有效率的选择。我的一个朋友在进行了多年的大型系统软件开发之后，不无感慨地说，C++最大的力量不在于其抽象，恰恰在于其不抽象 ^33692196-6-1002-1286
    - ⏱ 2022-08-09 20:21:44 

- 📌 缺少自动内存管理和对象级别的消息 ^33692196-6-1506-1522
    - ⏱ 2021-05-07 15:47:38 
## 前言


- 📌 · 使语言更为统一，更易于教学。· 使标准库更简单、安全、使用更高效。· 使编写高效率的抽象和库变得更简单 ^33692196-7-645-756
    - ⏱ 2022-08-09 20:37:19 

- 📌 智能指针和允许移动的容器 ^33692196-7-1033-1045
    - ⏱ 2021-05-07 15:50:38 

- 📌 · 低级语言，大部分继承自C语言。 ^33692196-7-1799-1816
    - ⏱ 2022-08-09 20:38:36 

- 📌 · 现代高级语言特性，允许我们定义自己的类型以及组织大规模程序和系统。 ^33692196-7-1845-1880
    - ⏱ 2022-08-09 20:38:59 

- 📌 · 标准库，它利用高级特性来提供有用的数据结构和算法。 ^33692196-7-1909-1936
    - ⏱ 2022-08-09 20:39:09 

- 📌 类型string和vector。 ^33692196-7-2213-2229
    - ⏱ 2022-08-09 20:39:27 

- 📌 基于字符数组指针和动态内存管理 ^33692196-7-2318-2333
    - ⏱ 2022-08-09 20:39:44 

- 📌 贯穿全书，我们都在强调好的风格：我们想帮助读者直接养成好的习惯，而不是在获得很多很复杂的知识后再去忘掉那些坏习惯。我们特别强调那些棘手的问题，并对常见的错误想法和陷阱提出警告。 ^33692196-7-2412-2500
    - ⏱ 2022-08-09 20:39:55 
## 1.1 编写一个简单的C++程序


- 📌 一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算。 ^33692196-9-2090-2124
    - ⏱ 2022-08-09 23:54:37 
## 1.3 注释简介


- 📌 错误的注释比完全没有注释更糟糕，因为它会误导读者。因此，当你修改代码时，不要忘记同时更新注释！ ^33692196-11-614-661
    - ⏱ 2022-08-12 16:43:09 
## 1.5 类简介


- 📌 包含来自标准库的头文件时，也应该用尖括号（<>）包围头文件名。对于不属于标准库的头文件，则用双引号（" "）包围。 ^33692196-13-3536-3593
    - ⏱ 2022-08-12 20:14:33 

- 📌 调用名为isbn的成员函数（member function）。成员函数是定义为类的一部分的函数，有时也被称为方法（method）。 ^33692196-13-6604-6739
    - ⏱ 2022-08-12 20:17:02 
## 第Ⅰ部分 C++基础


- 📌 与之相反，C++是一种静态数据类型语言，它的类型检查发生在编译时 ^33692196-17-2499-2531
    - ⏱ 2022-08-14 22:32:20 

- 📌 C++中最重要的语法特征应该就是类了，通过它，程序员可以定义自己的数据类型。 ^33692196-17-2840-2878
    - ⏱ 2022-08-14 22:34:34 
## 2.1 基本内置类型

 
 

- 📌 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。 ^33692196-19-4511-4551
    - ⏱ 2022-12-23 16:16:57 

- 📌 程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称作不可移植的（nonportable）。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。 ^33692196-19-7063-7195
    - ⏱ 2022-12-23 16:17:59 

- 📌 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。 ^33692196-19-9974-10034
    - ⏱ 2022-08-15 20:13:10 

- 📌 一类是不可打印（nonprintable）的字符，如退格或其他控制字符，因为它们没有可视的图符；另一类是在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线） ^33692196-19-13060-13178
    - ⏱ 2022-08-15 20:17:11 
## 2.2 变量


- 📌 对象是指一块能存储数据并具有某种类型的内存空间 ^33692196-20-1393-1416
    - ⏱ 2022-12-23 17:06:42 

- 📌 。很多程序员对于用等号=来初始化变量的方式倍感困惑，这种方式容易让人认为初始化是赋值的一种。事实上在C++语言中，初始化和赋值是两个完全不同的操作。然而在很多编程语言中二者的区别几乎可以忽略不计，即使在C++语言中有时这种区别也无关紧要，所以人们特别容易把二者混为一谈。需要强调的是，这个概念至关重要，我们也将在后面不止一次提及这一点。 ^33692196-20-2223-2391
    - ⏱ 2022-12-23 17:07:35 

- 📌 这种初始化的形式被称为列表初始化（list initialization） ^33692196-20-3412-3484
    - ⏱ 2022-08-16 12:32:08 

- 📌 如果我们使用列表初始化且初始值存在丢失信息的风险 ^33692196-20-3587-3611
    - ⏱ 2021-05-08 16:27:23 

- 📌 如果定义变量时没有指定初值，则变量被默认初始化（default initialized），此时变量被赋予了“默认值”。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响 ^33692196-20-4197-4323
    - ⏱ 2022-08-16 12:33:11 

- 📌 C++语言支持分离式编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。 ^33692196-20-6883-6948
    - ⏱ 2022-08-16 12:34:43 

- 📌 声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。 ^33692196-20-7164-7289
    - ⏱ 2021-05-08 16:30:53 

- 📌 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量 ^33692196-20-7406-7451
    - ⏱ 2021-05-08 16:31:03 

- 📌 用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头 ^33692196-20-9861-9921
    - ⏱ 2021-05-08 16:31:59 

- 📌 变量名一般用小写字母，如index，不要使用Index或INDEX。 ^33692196-20-10134-10168
    - ⏱ 2022-08-16 13:31:15 

- 📌 ：变量、函数、类型等 ^33692196-20-11520-11530
    - ⏱ 2022-08-16 13:31:42 

- 📌 名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。 ^33692196-20-11731-11765
    - ⏱ 2022-08-16 13:32:00 

- 📌 名字main定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有全局作用域（global scope） ^33692196-20-12373-12466
    - ⏱ 2022-08-16 13:32:13 

- 📌 建议：当你第一次使用变量时再定义它一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，因为这样做有助于更容易地找到变量的定义。更重要的是，当变量的定义与它第一次被使用的地方很近时，我们也会赋给它一个比较合理的初始值。 ^33692196-20-12747-12905
    - ⏱ 2021-05-08 16:33:54 
## 2.3 复合类型


- 📌 基于其他类型定义的类型 ^33692196-21-470-481
    - ⏱ 2021-05-08 16:34:35 

- 📌 引用和指针 ^33692196-21-506-511
    - ⏱ 2021-05-08 16:34:39 

- 📌 右值引用（rvalue reference） ^33692196-21-1220-1242
    - ⏱ 2022-08-16 13:33:14 

- 📌 左值引用 ^33692196-21-1317-1321
    - ⏱ 2021-05-08 16:35:16 

- 📌 引用即别名 ^33692196-21-1956-1961
    - ⏱ 2021-05-08 16:35:46 

- 📌 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字 ^33692196-21-2214-2247
    - ⏱ 2021-05-08 16:35:50 

- 📌 因为引用本身不是一个对象，所以不能定义引用的引用 ^33692196-21-2879-2903
    - ⏱ 2021-05-08 16:36:28 

- 📌 与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 ^33692196-21-4809-4957
    - ⏱ 2021-05-08 16:38:32 

- 📌 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。 ^33692196-21-6015-6045
    - ⏱ 2021-05-08 16:39:09 

- 📌 1.指向一个对象。2.指向紧邻对象所占空间的下一个位置。3.空指针，意味着指针没有指向任何对象。4.无效指针，也就是上述情况之外的其他值。 ^33692196-21-6603-6759
    - ⏱ 2021-05-08 16:39:40 

- 📌 试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的 ^33692196-21-6788-6847
    - ⏱ 2022-08-16 13:35:06 

- 📌 解引用符（操作符＊） ^33692196-21-7150-7167
    - ⏱ 2021-05-08 16:40:07 

- 📌 最直接的办法就是用字面值nullptr ^33692196-21-9185-9232
    - ⏱ 2021-05-08 16:41:35 

- 📌 过去的程序还会用到一个名为NULL的预处理变量（preprocessor variable）来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。 ^33692196-21-9386-9500
    - ⏱ 2021-05-08 16:41:44 

- 📌 在新标准下，现在的C++程序最好使用nullptr，同时尽量避免使用NULL ^33692196-21-9727-9765
    - ⏱ 2021-05-08 16:41:54 

- 📌 因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。 ^33692196-21-10517-10619
    - ⏱ 2021-05-08 16:42:29 

- 📌 指针和引用 ^33692196-21-10722-10727
    - ⏱ 2021-05-08 16:50:51 

- 📌 void＊是一种特殊的指针类型，可用于存放任意对象的地址。一个void＊指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解： ^33692196-21-12767-12859
    - ⏱ 2021-05-08 16:53:42 
## 2.4 const限定符


- 📌 与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象： ^33692196-22-4388-4419
    - ⏱ 2022-08-29 11:31:17 

- 📌 从右向左阅读 ^33692196-22-9095-9101
    - ⏱ 2022-01-24 20:12:33 

- 📌 另一方面，底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。 ^33692196-22-11985-12061
    - ⏱ 2022-01-24 20:15:23 
## 2.5 处理类型


- 📌 类型别名 ^33692196-23-590-594
    - ⏱ 2022-09-29 20:08:06 

- 📌 前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。 ^33692196-23-3312-3372
    - ⏱ 2022-09-29 20:25:19 

- 📌 auto ^33692196-23-3782-3793
    - ⏱ 2022-09-29 20:25:56 

- 📌 auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值： ^33692196-23-3853-3894
    - ⏱ 2022-09-29 20:26:04 

- 📌 auto一般会忽略掉顶层const（参见2.4.3节，第57页），同时底层const则会保留下来 ^33692196-23-5105-5153
    - ⏱ 2022-09-29 20:26:55 

- 📌 还可以将引用的类型设为auto，此时原来的初始化规则仍然适用： ^33692196-23-5691-5722
    - ⏱ 2022-09-29 20:27:06 

- 📌 decltype ^33692196-23-7245-7253
    - ⏱ 2022-09-29 20:27:42 

- 📌 decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）： ^33692196-23-8020-8110
    - ⏱ 2022-09-29 20:28:06 

- 📌 如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式 ^33692196-23-9364-9395
    - ⏱ 2021-05-11 16:36:04 

- 📌 decltype（（variable））（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。 ^33692196-23-9904-10099
    - ⏱ 2021-05-11 16:36:15 
## 2.6 自定义数据结构


- 📌 关键字struct开始，紧跟着类名和类体（其中类体部分可以为空） ^33692196-24-1310-1377
    - ⏱ 2022-09-29 20:30:41 

- 📌 data member）。 ^33692196-24-2331-2344
    - ⏱ 2022-09-29 20:36:04 
## 第3章 字符串、向量和数组


- 📌 string和vector是两种最重要的标准库类型 ^33692196-27-2226-2251
    - ⏱ 2022-09-29 20:41:49 

- 📌 可变长字符串，后者则表示可变长的集合 ^33692196-27-2256-2274
    - ⏱ 2022-09-29 20:42:00 
## 3.1 命名空间的using声明


- 📌 每个名字都需要独立的using声明 ^33692196-28-1388-1405
    - ⏱ 2022-09-29 20:44:05 

- 📌 头文件不应包含using声明 ^33692196-28-2189-2203
    - ⏱ 2021-05-11 16:42:53 

- 📌 如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。 ^33692196-28-2304-2344
    - ⏱ 2022-09-29 20:44:27 

- 📌 名字冲突 ^33692196-28-2378-2382
    - ⏱ 2022-09-29 20:44:41 
## 3.2 标准库类型string


- 📌 则该字面值中除了最后那个空字符外其他所有的字符都被拷贝到新创建的string对象中去 ^33692196-29-1707-1749
    - ⏱ 2022-09-29 20:47:03 

- 📌 直接初始化和拷贝初始化 ^33692196-29-2073-2084
    - ⏱ 2022-09-29 20:46:49 

- 📌 拷贝初始化 ^33692196-29-2246-2251
    - ⏱ 2021-05-11 16:45:16 

- 📌 直接初始化 ^33692196-29-2350-2355
    - ⏱ 2021-05-11 16:45:23 

- 📌 getline函数代替原来的>>运算符 ^33692196-29-5716-5735
    - ⏱ 2022-09-29 20:50:28 

- 📌 但其实size函数返回的是一个string：：size_type类型的值，下面就对这种新的类型稍作解释。 ^33692196-29-7873-7925
    - ⏱ 2022-09-29 20:52:15 

- 📌 size_type ^33692196-29-8037-8046
    - ⏱ 2021-08-11 17:35:11 

- 📌 但有一点是肯定的：它是一个无符号类型的值 ^33692196-29-8166-8186
    - ⏱ 2022-06-15 11:03:59 

- 📌 如果一条表达式中已经有了size（）函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。 ^33692196-29-9242-9301
    - ⏱ 2022-09-29 20:52:43 

- 📌 目前最好的办法是使用C++11新标准提供的一种语句：范围for（range for）语句 ^33692196-29-15656-15735
    - ⏱ 2022-06-15 16:45:26 

- 📌 如果想要改变string对象中字符的值，必须把循环变量定义成引用类型 ^33692196-29-17642-17676
    - ⏱ 2022-09-29 20:56:50 

- 📌 要想访问string对象中的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器，其中关于迭代器的内容将在3.4节（第95页）和第9章中介绍。 ^33692196-29-18929-19002
    - ⏱ 2022-06-15 16:48:46 
## 3.3 标准库类型vector


- 📌 vector ^33692196-30-456-462
    - ⏱ 2021-05-11 17:02:16 

- 📌 容器（container） ^33692196-30-573-593
    - ⏱ 2021-05-11 17:02:12 

- 📌 模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化（instantiation），当使用模板时，需要指出编译器应把类或函数实例化成何种类型。 ^33692196-30-1116-1255
    - ⏱ 2021-05-11 17:02:50 

- 📌 vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int> ^33692196-30-2034-2093
    - ⏱ 2022-06-15 17:05:52 

- 📌 目前已经介绍过的两种例外情况是：其一，使用拷贝初始化时（即使用=时）（参见3.2.1节，第76页），只能提供一个初始值 ^33692196-30-4937-4996
    - ⏱ 2021-08-19 16:17:26 

- 📌 其二，如果提供的是一个类内初始值（参见2.6.1节，第64页），则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里： ^33692196-30-4997-5109
    - ⏱ 2021-08-19 16:17:33 

- 📌 初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号 ^33692196-30-6972-7000
    - ⏱ 2021-08-19 16:19:16 

- 📌 如果用的是圆括号，可以说提供的值是用来构造（construct）vector对象的。例如，v1的初始值说明了vector对象的容量；v3的两个初始值则分别说明了vector对象的容量和元素的初值。 ^33692196-30-7418-7516
    - ⏱ 2021-08-19 16:19:53 

- 📌 如果用的是花括号，可以表述成我们想列表初始化（list initialize）该vector对象。也就是说，初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。在上例中，给v2和v4提供的初始值都能作为元素的值，所以它们都会执行列表初始化，vector对象v2包含一个元素而vector对象v4包含两个元素。 ^33692196-30-7545-7730
    - ⏱ 2021-08-19 16:19:56 

- 📌 C++标准要求vector应该能在运行时高效快速地添加元素。因此既然vector对象能高效地增长，那么在定义vector对象的时候设定其大小也就没什么必要了，事实上如果这么做性能可能更差。只有一种例外情况，就是所有（all）元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的vector对象，再在运行时向其中添加具体值。此外，9.4节（第317页）将介绍，vector还提供了方法，允许我们进一步提升动态添加元素的性能。 ^33692196-30-10495-10713
    - ⏱ 2021-08-19 16:41:39 

- 📌 开始的时候创建空的vector对象，在运行时再动态添加元素，这一做法与C语言及其他大多数语言中内置数组类型的用法不同。特别是如果用惯了C或者Java，可以预计在创建vector对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。 ^33692196-30-10752-10872
    - ⏱ 2021-08-19 16:42:07 
 

- 📌 不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出（buffer overflow）指的就是这类错误，这也是导致PC及其他设备上应用程序出现安全问题的一个重要原因 ^33692196-30-17920-18023
    - ⏱ 2021-08-19 17:16:41 
## 3.4 迭代器介绍


- 📌 string对象不属于容器类型，但是string支持很多与容器类型类似的操作 ^33692196-31-613-651
    - ⏱ 2021-05-11 17:09:27 

- 📌 迭代器也提供了对对象的间接访问 ^33692196-31-756-771
    - ⏱ 2021-05-11 17:09:43 

- 📌 和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器 ^33692196-31-989-1159
    - ⏱ 2021-05-11 17:10:23 

- 📌 end成员则负责返回指向容器（或string对象）“尾元素的下一位置（one past the end）”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“尾后（off the end）”元素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end成员返回的迭代器常被称作尾后迭代器（off-the-end iterator）或者简称为尾迭代器（end iterator） ^33692196-31-1411-1688
    - ⏱ 2021-05-11 17:10:33 

- 📌 原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！=而非<进行判断有点儿奇怪，比如上面的这个程序以及85页的那个。C++程序员习惯性地使用！=，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。 ^33692196-31-4625-4761
    - ⏱ 2021-05-11 17:14:22 

- 📌 迭代器这个名词有三种不同的含义：可能是迭代器概念本身，也可能是指容器定义的迭代器类型，还可能是指某个迭代器对象 ^33692196-31-5709-5764
    - ⏱ 2021-05-11 17:14:50 

- 📌 const_iterator ^33692196-31-7289-7303
    - ⏱ 2021-05-11 17:15:42 

- 📌 为了简化上述表达式，C++语言定义了箭头运算符（->）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，it->mem和（＊it）.mem表达的意思相同。 ^33692196-31-8258-8381
    - ⏱ 2021-08-19 17:19:43 

- 📌 已知的一个限制是不能在范围for循环中向vector对象添加元素 ^33692196-31-9085-9117
    - ⏱ 2021-05-11 17:16:47 

- 📌 任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效 ^33692196-31-9125-9177
    - ⏱ 2021-05-11 17:16:57 

- 📌 谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素 ^33692196-31-9452-9485
    - ⏱ 2021-08-19 17:21:07 
## 3.5 数组


- 📌 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。 ^33692196-32-1721-1794
    - ⏱ 2021-08-20 09:39:17 

- 📌 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值 ^33692196-32-2950-2985
    - ⏱ 2021-05-11 17:35:41 

- 📌 一些编译器支持数组的赋值，这就是所谓的编译器扩展（compiler extension）。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。 ^33692196-32-3447-3574
    - ⏱ 2021-05-11 17:35:51 

- 📌 在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。 ^33692196-32-6192-6351
    - ⏱ 2021-08-20 16:43:25 

- 📌 一个潜在的问题是，我们在估算largeStr所需的空间时不容易估准，而且largeStr所存的内容一旦改变，就必须重新检查其空间是否足够。不幸的是，这样的代码到处都是，程序员根本没法照顾周全。这类代码充满了风险而且经常导致严重的安全泄漏。 ^33692196-32-22465-22584
    - ⏱ 2021-05-11 17:44:55 

- 📌 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。 ^33692196-32-24371-24411
    - ⏱ 2021-05-11 17:45:26 

- 📌 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。 ^33692196-32-24442-24537
    - ⏱ 2021-05-11 17:45:36 
## 3.6 多维数组


- 📌 严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。 ^33692196-33-416-475
    - ⏱ 2021-05-11 17:46:59 
## 4.1 基础


- 📌 我们知道f1和f2一定会在执行乘法之前被调用，因为毕竟相乘的是这两个函数的返回值。但是我们无法知道到底f1在f2之前调用还是f2在f1之前调用。 ^33692196-37-7315-7387
    - ⏱ 2021-05-11 23:11:55 

- 📌 因为此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的。 ^33692196-37-7875-7912
    - ⏱ 2021-05-11 23:12:09 

- 📌 对于这些函数的调用顺序没有明确规定。 ^33692196-37-8438-8456
    - ⏱ 2021-05-11 23:12:27 

- 📌 C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地 ^33692196-37-9245-9281
    - ⏱ 2021-05-11 23:12:49 
## 4.2 算术运算符


- 📌 我们指出布尔值不应该参与运算，-b就是一个很好的例子 ^33692196-38-1376-1402
    - ⏱ 2021-05-11 23:13:29 

- 📌 溢出和其他算术运算异常 ^33692196-38-1640-1651
    - ⏱ 2021-05-11 23:13:43 

- 📌 C++语言的早期版本允许m%n的符号匹配n的符号，而且商向负无穷一侧取整，这一方式在新标准中已经被禁止使用了。除了-m导致溢出的特殊情况，其他时候（-m）/n和m/（-n）都等于-（m/n），m%（-n）等于m%n，（-m）%n等于-（m%n） ^33692196-38-3526-3648
    - ⏱ 2021-05-11 23:14:54 
## 第7章 类


- 📌 数据抽象（data abstraction）和封装（encapsulation ^33692196-70-2625-2706
    - ⏱ 2021-05-12 09:58:50 

- 📌 接口（interface） ^33692196-70-2746-2766
    - ⏱ 2021-05-12 09:58:58 

- 📌 实现（implementation） ^33692196-70-2795-2820
    - ⏱ 2021-05-12 09:59:01 

- 📌 类的实现则包括类的数据成员 ^33692196-70-2850-2863
    - ⏱ 2021-05-12 09:59:06 

- 📌 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。 ^33692196-70-2918-2974
    - ⏱ 2021-05-12 09:59:12 

- 📌 抽象数据类型（abstract data type） ^33692196-70-3052-3085
    - ⏱ 2021-05-12 09:59:22 
## 7.1 定义抽象数据类型


- 📌 在一些简单的应用程序中，类的用户和类的设计者常常是同一个人。尽管如此，还是最好把角色区分开来。当我们设计类的接口时，应该考虑如何才能使得类易于使用；而当我们使用类时，不应该顾及类的实现机理。 ^33692196-71-2196-2291
    - ⏱ 2021-05-12 10:00:36 

- 📌 要想开发一款成功的应用程序，其作者必须充分了解并实现用户的需求。同样，优秀的类设计者也应该密切关注那些有可能使用该类的程序员的需求。作为一个设计良好的类，既要有直观且易于使用的接口，也必须具备高效的实现过程。 ^33692196-71-2330-2434
    - ⏱ 2021-05-12 10:00:43 

- 📌 类还需要控制拷贝、赋值和销毁对象时发生的行为 ^33692196-71-23754-23776
    - ⏱ 2021-05-12 10:14:51 

- 📌 我们初始化变量以及以值的方式传递或返回一个对象等 ^33692196-71-23791-23815
    - ⏱ 2021-05-12 10:14:57 

- 📌 当我们使用了赋值运算符（参见4.4节，第129页）时会发生对象的赋值操作 ^33692196-71-23845-23881
    - ⏱ 2021-05-12 10:15:07 

- 📌 当对象不再存在时执行销毁的操作，比如一个局部对象会在创建它的块结束时被销毁 ^33692196-71-23882-23919
    - ⏱ 2021-05-12 10:15:12 
## 7.2 访问控制与封装


- 📌 访问说明符（access specifiers）加强类的封装性 ^33692196-72-537-575
    - ⏱ 2021-05-12 10:17:11 

- 📌 public ^33692196-72-638-644
    - ⏱ 2021-05-12 10:17:13 

- 📌 private ^33692196-72-747-754
    - ⏱ 2021-05-12 10:17:16 

- 📌 struct和class的默认访问权限不太一样 ^33692196-72-1606-1629
    - ⏱ 2021-05-12 10:17:42 

- 📌 使用class和struct定义类唯一的区别就是默认的访问权限 ^33692196-72-2122-2153
    - ⏱ 2021-05-12 10:17:59 

- 📌 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。 ^33692196-72-2909-2992
    - ⏱ 2021-05-12 10:18:19 

- 📌 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束 ^33692196-72-3496-3552
    - ⏱ 2021-05-12 10:18:48 

- 📌 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。 ^33692196-72-4893-4972
    - ⏱ 2021-05-12 10:20:59 

- 📌 友元的声明与类本身放置在同一个头文件中（类的外部 ^33692196-72-5019-5043
    - ⏱ 2021-05-12 10:21:06 
## 7.3 类的其他特性


- 📌 它的this指针将隐式地从指向非常量的指针转换成指向常量的指针 ^33692196-73-10004-10035
    - ⏱ 2021-05-12 10:29:10 

- 📌 一个基本的愿望是避免在多处使用同样的代码 ^33692196-73-10752-10773
    - ⏱ 2021-05-12 10:29:39 
## 9.1 顺序容器概述


- 📌 向容器添加或从容器中删除元素的代价 ^33692196-87-505-522
    - ⏱ 2021-05-12 15:43:47 

- 📌 非顺序访问容器中元素的代价 ^33692196-87-553-566
    - ⏱ 2021-05-12 15:43:50 

- 📌 其他容器都提供高效、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作 ^33692196-87-823-923
    - ⏱ 2021-05-12 15:44:01 
## 9.3 顺序容器操作


- 📌 deque保证在容器首尾进行插入和删除元素的操作都只花费常数时间 ^33692196-89-2957-2989
    - ⏱ 2021-05-12 17:28:43 

- 📌 与vector一样，在deque首尾之外的位置插入元素会很耗时 ^33692196-89-2990-3021
    - ⏱ 2021-05-12 17:28:36 

- 📌 emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应push_front、insert和push_back，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。 ^33692196-89-7033-7147
    - ⏱ 2021-05-12 17:30:12 
## 9.4 vector对象是如何增长的


- 📌 快速随机访问 ^33692196-90-425-431
    - ⏱ 2021-05-12 17:37:57 
## 小结


- 📌 所有容器（除array外）都提供高效的动态内存管理 ^33692196-93-539-564
    - ⏱ 2021-05-12 17:48:47 

- 📌 我们可以向容器中添加元素，而不必担心元素存储在哪里。容器负责管理自身的存储。vector和string都提供更细致的内存管理控制，这是通过它们的reserve和capacity成员函数来实现的。 ^33692196-93-565-662
    - ⏱ 2021-05-12 17:48:58 
# 读书笔记

## 2.1 基本内置类型

### 划线评论
- 📌 C++语言规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大。  ^2009032-7EIGes7Jb
    - 💭 所以C++标准并没有规定int、short、long这些整数类型所占据的内存大小，很多时候是根据机器平台确定的。另外，很多大型软件里面会规定自己的变量类型，就是为了和C++原始的数据类型弄混
    - ⏱ 2022-12-23 16:13:45

### 划线评论
- 📌 浮点型可表示单精度、双精度和扩展精度值。C++标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，float以1个字（32比特）来表示，double以2个字（64比特）来表示，long double以3或4个字（96或128比特）来表示。一般来说，类型float和double分别有7和16个有效位；类型long double则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。  ^2009032-7EIGmXkLV
    - 💭 High Level : 定点数。可以详细了解一下游戏行业使用的定点数。
    - ⏱ 2022-12-23 16:15:50
   
## 3.3 标准库类型vector

### 划线评论
- 📌 范围for语句体内不应改变其所遍历序列的大小  ^2009032-7sFQgezdX
    - 💭 这个问题本身很简单，也很容易规避，但是在实际的开发工作中，尤其是上层业务非常复杂的情况下，很容易就会出现在一个列表修改的过程中，尝试去删除或者去添加新的元素。
    - ⏱ 2021-08-19 16:43:56
   
# 本书评论
