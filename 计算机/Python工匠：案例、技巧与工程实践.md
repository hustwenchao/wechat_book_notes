---
doc_type: weread-highlights-reviews
bookId: "3300018868"
author: 朱雷
cover: https://cdn.weread.qq.com/weread/cover/68/3300018868/t7_3300018868.jpg
reviewCount: 7
noteCount: 74
isbn: 9787115584045
category: 计算机-编程设计
lastReadDate: 2023-08-21
---
# 元数据
> [!abstract] Python工匠：案例、技巧与工程实践
> - ![ Python工匠：案例、技巧与工程实践|200](https://cdn.weread.qq.com/weread/cover/68/3300018868/t7_3300018868.jpg)
> - 书名： Python工匠：案例、技巧与工程实践
> - 作者： 朱雷
> - 简介： 本书基于受欢迎的“Python工匠”系列开源文章。全书从工程实践角度出发，通过剖析核心知识、展示典型案例与总结实用技巧，帮助大家系统进阶Python，写好工程代码，做好实践项目。  本书共计13章，分为五大部分：变量与基础类型、语法结构、函数与装饰器、面向对象编程、总结与延伸，涵盖Python编程的方方面面。本书的写作方式别具一格，核心知识点都会通过三大板块来阐述：基础知识、案例故事、编程建议。其中基础知识帮助大家快速回顾Python基础；案例故事由作者经历的编程项目与案例改编而来，兼具实战性与趣味性；编程建议以大家喜闻乐见的条目式知识点呈现，短小精悍，可直接应用于自己的编程实践中。
> - 出版时间 2022-03-01 00:00:00
> - ISBN： 9787115584045
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社有限公司

# 高亮划线

## 为什么写这本书


- 📌 在接手了几个被众人称为“坑”的老项目，或是亲手写了一些无人敢接手的代码后；在整日忙着修bug，每写一个新功能就引入三个新bug后……夜深人静之时，坐在电脑前埋头苦干的我们总有那么一些瞬间会突然意识到：编程最初带给我们的快乐已悄然远去，写代码这件事现在变得有些痛苦。更有甚者，一想到项目里的烂代码，每天起床后最想干的一件事就是辞职。 ^3300018868-5-684-849
    - ⏱ 2023-05-11 16:24:00 
## 第1章 变量与注释


- 📌 好的变量和注释并非为计算机而写，而是为每个阅读代码的人而写（当然也包括你自己）。 ^3300018868-12-1786-1826
    - ⏱ 2023-05-24 23:18:49 
## 1.1 基础知识


- 📌 动态类型 ^3300018868-13-733-737
    - ⏱ 2023-05-24 23:19:02 

- 📌 除了上面的普通解包外，Python还支持更灵活的动态解包语法。只要用星号表达式（*variables）作为变量名，它便会贪婪￼地捕获多个值对象，并将捕获到的内容作为列表赋值给variables。 ^3300018868-13-1731-1991
    - ⏱ 2023-05-24 23:19:49 
 

- 📌 动态类型所带来的缺点是代码的可读性会因此大打折扣。 ^3300018868-13-3809-3834
    - ⏱ 2023-05-24 23:21:30 

- 📌 相比编写Sphinx格式文档，我其实更推荐使用类型注解，因为它是Python的内置功能，而且正在变得越来越流行。 ^3300018868-13-4731-4787
    - ⏱ 2023-05-24 23:22:05 

- 📌 因此，我强烈建议在多人参与的中大型Python项目里，至少使用一种类型注解方案——Sphinx格式文档或官方类型注解都行。能直接看到变量类型的代码，总是会让人更安心。 ^3300018868-13-5950-6059
    - ⏱ 2023-05-24 23:22:38 

- 📌 计算机科学领域只有两件难事：缓存失效和命名。——Phil Karlton ^3300018868-13-6914-6982
    - ⏱ 2023-05-24 23:22:57 

- 📌 为了让不同开发者写出的代码风格尽量保持统一，Python制定了官方的编码风格指南：PEP 8。 ^3300018868-13-7391-7438
    - ⏱ 2023-05-24 23:23:20 

- 📌 为变量命名要结合代码情境和上下文 ^3300018868-13-9924-9940
    - ⏱ 2023-05-24 23:24:25 

- 📌 对于不再需要的代码，我们应该直接把它们删掉，而不是注释掉。 ^3300018868-13-15089-15118
    - ⏱ 2023-05-24 23:26:17 

- 📌 在编写注释时，新手常犯的另一类错误是用注释复述代码。 ^3300018868-13-15264-15290
    - ⏱ 2023-05-24 23:26:26 

- 📌 指引性注释 ^3300018868-13-15811-15823
    - ⏱ 2023-05-24 23:26:46 
## 1.3 编程建议


- 📌 在组织代码时，我们应该谨记：总是从代码的职责出发，而不是其他东西。 ^3300018868-15-2604-2663
    - ⏱ 2023-05-24 23:29:18 

- 📌 直接翻译业务逻辑的代码，大多不是好代码。优秀的程序设计需要在理解原需求的基础上，恰到好处地抽象，只有这样才能同时满足可读性和可扩展性方面的需求。抽象有许多种方式，比如定义新函数、定义新类型，“定义一个临时变量”是诸多方式里不太起眼的一个，但用得恰当的话效果也很巧妙。 ^3300018868-15-4472-4605
    - ⏱ 2023-05-24 23:29:47 

- 📌 Python之禅：显式优于隐式 ^3300018868-15-9453-9468
    - ⏱ 2023-05-24 23:30:53 
## 第2章 数值与字符串

 

- 📌 字节串类型（bytes） ^3300018868-17-1440-1452
    - ⏱ 2023-05-25 16:29:04 
## 2.1 基础知识


- 📌 decimal ^3300018868-18-2007-2014
    - ⏱ 2023-05-25 16:30:36 

- 📌 任何问题应有一种且最好只有一种显而易见的解决方法。 ^3300018868-18-4865-4890
    - ⏱ 2023-05-25 16:33:23 

- 📌 虽然年轻的f-string抢走了str.format的大部分风头，但后者仍有着自己的独到之处。 ^3300018868-18-6511-6558
    - ⏱ 2023-05-25 16:35:02 

- 📌 （1）字符串：我们最常挂在嘴边的“普通字符串”，有时也被称为文本（text），是给人看的，对应Python中的字符串（str）类型。str使用Unicode标准，可通过.encode()方法编码为字节串。（2）字节串：有时也称“二进制字符串”（binary string），是给计算机看的，对应Python中的字节串（bytes）类型。bytes一定包含某种真正的字符串编码格式（默认为UTF-8），可通过.decode()解码为字符串。 ^3300018868-18-10058-10384
    - ⏱ 2023-05-25 17:03:03 
## 2.2 案例故事


- 📌 这种因为输入错误导致的bug并不少见，而且隐蔽性特别强。 ^3300018868-19-3227-3255
    - ⏱ 2023-05-25 19:30:26 

- 📌 SQLAlchemy ^3300018868-19-5619-5629
    - ⏱ 2023-05-25 19:31:28 
## 2.4 总结


- 📌 在看到一些写代码的“经验之谈”时，你最好抱着怀疑精神，因为Python语言进化得特别快，稍不留神，以往的经验就会过时。如果需要验证某个“经验之谈”，dis和timeit两个优秀的工具可以帮到你：前者能让你直接查看编译后的字节码，后者则能让你方便地做性能测试。保持怀疑、多多实验，有助于你成长为更优秀的程序员。 ^3300018868-21-698-852
    - ⏱ 2023-05-26 13:40:23 
## 第3章 容器类型


- 📌 列表、元组、字典、集合 ^3300018868-22-608-619
    - ⏱ 2023-05-26 13:41:43 
## 3.1 基础知识


- 📌 列表推导式（list comprehension） ^3300018868-23-2828-2860
    - ⏱ 2023-05-26 13:44:08 

- 📌 · 可变（mutable）：列表、字典、集合。· 不可变（immutable）：整数、浮点数、字符串、字节串、元组。 ^3300018868-23-3452-3593
    - ⏱ 2023-05-26 13:44:34 

- 📌 由此可见，Python的函数调用不能简单归类为“值传递”或者“引用传递”，一切行为取决于对象的可变性。 ^3300018868-23-8054-8105
    - ⏱ 2023-05-27 23:31:41 

- 📌 不过，如果只是“提供默认值的读取操作”，其实可以直接使用字典的.get()方法。 ^3300018868-23-14870-14910
    - ⏱ 2023-05-27 23:34:10 

- 📌 对象的可哈希性 ^3300018868-23-24164-24171
    - ⏱ 2023-05-31 19:21:47 

- 📌 首先，那些不可变的内置类型都是可哈希的： ^3300018868-23-24523-24543
    - ⏱ 2023-05-31 19:22:17 

- 📌 而可变的内置类型都无法正常计算哈希值： ^3300018868-23-24779-24798
    - ⏱ 2023-05-31 19:22:22 

- 📌 （1）所有的不可变内置类型，都是可哈希的，比如str、int、tuple、frozenset等；（2）所有的可变内置类型，都是不可哈希的，比如dict、list等；（3）对于不可变容器类型(tuple, frozenset)，仅当它的所有成员都不可变时，它自身才是可哈希的；（4）用户定义的类型默认都是可哈希的。 ^3300018868-23-25492-25735
    - ⏱ 2023-05-31 19:22:54 
## 3.3 编程建议


- 📌 生成器（generator）是Python里的一种特殊的数据类型。顾名思义，它是一个不断给调用方“生成”内容的类型。 ^3300018868-25-1760-1825
    - ⏱ 2023-05-31 19:25:53 

- 📌 要实现合并功能，需要用到双星号**运算符来做解包操作。在字典中使用**dict_obj表达式，可以动态解包dict_obj字典的所有内容，并与当前字典合并： ^3300018868-25-9419-9497
    - ⏱ 2023-05-31 19:29:47 

- 📌 合理利用*和**运算符，可以帮助我们高效构建列表与字典对象。 ^3300018868-25-10232-10262
    - ⏱ 2023-05-31 19:30:07 

- 📌 别在遍历列表时同步修改 ^3300018868-25-11641-11653
    - ⏱ 2023-05-31 19:30:56 
## 4.1 基础知识


- 📌 假如一个类同时定义了__len__和__bool__两个方法，解释器会优先使用__bool__方法的执行结果。 ^3300018868-28-6325-6380
    - ⏱ 2023-05-31 19:36:55 

- 📌 对于从-5到256的这些常用小整数，Python会将它们缓存在内存里的一个数组中。当你的程序需要用到这些数字时，Python不会创建任何新的整型对象，而是会返回缓存中的对象。这样能为程序节约可观的内存。 ^3300018868-28-9006-9107
    - ⏱ 2023-05-31 19:43:59 
## 4.3 编程建议


- 📌 提前返回 ^3300018868-30-1539-1543
    - ⏱ 2023-06-07 16:30:31 

- 📌 别写太复杂的条件表达式 ^3300018868-30-2501-2512
    - ⏱ 2023-06-07 16:31:06 

- 📌 在Python的众多内置函数中，有两个特别适合在构建条件表达式时使用，它们就是all()和any()。这两个函数接收一个可迭代对象作为参数，返回一个布尔值结果。 ^3300018868-30-7129-7209
    - ⏱ 2023-06-07 16:31:42 

- 📌 出现这个结果的原因是：and运算符的优先级高于or。因此在Python看来，上面第二个表达式实际上等同于True or (False and False)，所以最终结果是True而不是False。 ^3300018868-30-8384-8482
    - ⏱ 2023-06-07 16:32:34 

- 📌 因为or计算的是变量的布尔真假值，所以不光是None，0、[]、{}以及其他所有布尔值为假的东西，都会在or运算中被忽略： ^3300018868-30-9651-9712
    - ⏱ 2023-06-07 16:33:08 
## 5.1 基础知识


- 📌 LBYL（look before you leap） ^3300018868-33-1633-1659
    - ⏱ 2023-06-07 19:29:29 

- 📌 EAFP（easier to ask for forgiveness than permission） ^3300018868-33-1856-1907
    - ⏱ 2023-06-07 19:29:38 

- 📌 一个显而易见的原因是，EAFP风格的代码通常会更精简。因为它不要求开发者用分支完全覆盖各种可能出错的情况，只需要捕获可能发生的异常即可。另外，EAFP风格的代码通常性能也更好。比如在这个例子里，假如你每次都用字符串'73'来调用函数，这两种风格的代码在操作流程上会有如下区别。（1）LBYL：每次调用都要先进行额外的isinstance和isdigit判断。（2） EAFP：每次调用直接执行转换，返回结果。 ^3300018868-33-2756-3018
    - ⏱ 2023-06-07 19:30:01 
## 5.2 案例故事


- 📌 · 永远只捕获那些可能会抛出异常的语句块；· 尽量只捕获精确的异常类型，而不是模糊的Exception；· 如果出现了预期外的异常，让程序早点儿崩溃也未必是件坏事。 ^3300018868-34-3326-3470
    - ⏱ 2023-06-07 19:40:58 

- 📌 让模块只抛出与当前抽象级别一致的异常；· 在必要的地方进行异常包装与转换。 ^3300018868-34-7121-7190
    - ⏱ 2023-06-07 19:42:11 
## 5.3 编程建议


- 📌 assert是一个专供开发者调试程序的关键字。它所提供的断言检查，可以在执行Python时使用-O选项直接跳过： ^3300018868-35-8213-8269
    - ⏱ 2023-06-08 09:44:18 

- 📌 unset命令的例子体现出了一种程序设计技巧：在设计API时，如果稍微调整一下思考问题的角度，修改API的抽象定义，那么那些原本需要处理的错误，也许就会神奇地消失。假如API不抛出错误，调用方也就不需要处理错误，这会大大减轻大家的心智负担。 ^3300018868-35-9508-9628
    - ⏱ 2023-06-08 09:44:57 
 
## 第6章 循环与可迭代对象


- 📌 可迭代对象 ^3300018868-37-1504-1509
    - ⏱ 2023-06-08 11:04:36 
## 6.1 基础知识


- 📌 迭代器最鲜明的特征是：不断对它执行next()函数会返回下一次迭代结果。 ^3300018868-38-1673-1709
    - ⏱ 2023-06-08 11:06:20 

- 📌 itertools ^3300018868-38-14714-14723
    - ⏱ 2023-06-14 19:55:13 
## 6.2 案例故事


- 📌 小R在代码里所使用的文件读取方式，可谓Python里的“标准做法”：首先用with open (fine_name)上下文管理器语法获得一个文件对象，然后用for循环迭代它，逐行获取文件里的内容。为什么这种文件读取方式会成为标准？这是因为它有两个好处：（1）with上下文管理器会自动关闭文件描述符；（2）在迭代文件对象时，内容是一行一行返回的，不会占用太多内存。 ^3300018868-39-2006-2301
    - ⏱ 2023-06-14 19:57:44 
## 6.3 编程建议


- 📌 因此在平时，你需要将生成器（迭代器）的“可被一次性耗尽”特点铭记于心，避免写出由它所导致的bug。假如要重复使用一个生成器，可以调用list()函数将它转成列表后再使用。 ^3300018868-40-5234-5319
    - ⏱ 2023-06-14 20:06:15 

- 📌 除了生成器函数、生成器表达式以外，人们还常常忽略内置的map()、filter()函数也会返回一个一次性的迭代器对象。在使用这些函数时，也请务必当心。 ^3300018868-40-5489-5564
    - ⏱ 2023-06-14 20:06:23 
## 第7章 函数


- 📌 而消除重复代码，只是函数所提供给我们的众多好处之一。如果以它为起点，向四周继续发散，你会发现更多有趣的编程概念，包括高阶函数（higher-order function）、闭包（closure）、装饰器（decorator），等等。深入理解和掌握这些概念，是成为一名合格程序员的必经之路。 ^3300018868-42-762-984
    - ⏱ 2023-06-14 20:09:01 
## 7.1 基础知识


- 📌 之所以出现这个问题，是因为Python函数的参数默认值只会在函数定义阶段被创建一次，之后不论再调用多少次，函数内拿到的默认值都是同一个对象。 ^3300018868-43-1362-1458
    - ⏱ 2023-06-15 14:15:26 

- 📌 为了规避这个问题，使用None来替代可变类型默认值是比较常见的做法 ^3300018868-43-2020-2053
    - ⏱ 2023-06-15 14:30:58 
 

- 📌 好的函数设计一定是简单的，这种简单体现在各个方面。返回多种类型明显违反了简单原则。这种做法不光会给函数本身增加不必要的复杂度，还会提高用户理解和使用函数的成本。 ^3300018868-43-6827-6907
    - ⏱ 2023-06-15 14:34:02 

- 📌 “单一出口”的由来在写这部分内容时，我特意查询了“单一出口”原则的历史，以下是我的发现。在几十年前，汇编与FORTRAN语言流行的年代，编程语言拥有令人头疼的灵活性，你可以用各种花样在代码内随意跳转，这导致程序员很容易写出各种难以调试的代码。为了解决这个问题，著名计算机科学家Dijkstra提出了“单一入口，单一出口”（Single Entry, Single Exit）原则。在这个原则中，“单一出口”的意思是：函数（子程序）应该只从同一个地方跳出。这样一来事情就很明朗了。在现代编程语言里，无论函数内部有多少个return语句，函数的出口都是统一的——通往上层调用栈，所以这完全不属于最初的“单一出口”原则所担心的范围。即使后来“单一出口”原则发展出了别的含义，它也只针对一些特定的编程语言、编程场景有意义。比如在特定环境下，不恰当的返回会导致程序资源泄露等问题，所以要把返回统一起来管理。但在Python中，“单一出口原则建议函数只写一个return”只能算是一种误读，在“单一出口”和“多多返回”之间，我们完全可以选择可读性更强的那个。 ^3300018868-43-12433-13099
    - ⏱ 2023-06-15 14:37:55 

- 📌 lru_cache() ^3300018868-43-15380-15391
    - ⏱ 2023-06-15 14:39:12 
## 7.2 案例故事


- 📌 在函数式编程（functional programming）领域，有一个术语纯函数（pure function）。它最大的特点是，假如输入参数相同，输出结果也一定相同，不受任何其他因素影响。换句话说，纯函数是一种无状态的函数。 ^3300018868-44-412-577
    - ⏱ 2023-06-15 14:47:21 

- 📌 闭包（closure）是编程语言领域里的一个专有名词。简单来说，闭包是一种允许函数访问已执行完成的其他函数里的私有变量的技术，是为函数增加状态的另一种方式。 ^3300018868-44-6420-6505
    - ⏱ 2023-06-15 14:49:09 
## 7.3 编程建议


- 📌 别写太复杂的函数 ^3300018868-45-579-587
    - ⏱ 2023-06-15 14:54:08 

- 📌 分层思想 ^3300018868-45-4351-4355
    - ⏱ 2023-06-15 14:56:30 
## 8.1 基础知识


- 📌 装饰器是一种通过包装目标函数来修改其行为的特殊高阶函数，绝大多数装饰器是利用函数的闭包原理实现的。 ^3300018868-48-495-551
    - ⏱ 2023-08-21 17:34:35 
## 8.2 编程建议


- 📌 装饰器带来的改变，主要在于把修改函数的调用提前到了函数定义处，而这一点儿位置上的小变化，重塑了读者理解代码的整个过程。 ^3300018868-49-652-711
    - ⏱ 2023-08-21 19:20:13 
## 第9章 面向对象编程


- 📌 @classmethod、@staticmethod等装饰器来定义特殊方法 ^3300018868-51-1560-1597
    - ⏱ 2023-08-21 19:21:43 
# 读书笔记

## 为什么写这本书

### 划线评论
- 📌 生成器  ^2009032-7I880FyLf
    - 💭 应该是迭代器吧？
    - ⏱ 2023-05-11 16:25:22
   
## 获取本书示例代码

### 划线评论
- 📌 作为一本编程图书，本书包含许多代码示例。如果你想在自己的电脑上运行这些代码，做一些简单的修改和测试，可以访问本书的图灵社区主页[插图]下载书中所有代码示例源文件。  ^2009032-7IiDaRc7V
    - 💭 为啥不放在GitHub，放在图灵的社区？？？
    - ⏱ 2023-05-18 14:07:55
   
## 1.1 基础知识

### 划线评论
- 📌 单下划线变量名_  ^2009032-7IslfFywe
    - 💭 dummy value
    - ⏱ 2023-05-24 23:20:58
   
## 第2章 数值与字符串

### 划线评论
- 📌 和数字一样，Python里的字符串（string）也很容易上手[插图]。它直接兼容所有的Unicode字符，处理起中文来非常方便：  ^2009032-7ItqxVOCw
    - 💭 Python 2 里面的坑还是不少的。
    - ⏱ 2023-05-25 16:28:29
   
## 5.3 编程建议

### 划线评论
- 📌 简单来说，“空对象模式”就是本该返回None值或抛出异常时，返回一个符合正常结果接口的特制“空类型对象”来代替，以此免去调用方的错误处理工作。  ^2009032-7IOiyiKiO
    - 💭 按照这个理论，其实返回空列表，空字符串，都要比None要好。因为很多的上层调用接口会默认返回的列表不是None，用for循环来读取，就会导致抛出异常。
    - ⏱ 2023-06-08 09:46:31
   
## 6.1 基础知识

### 划线评论
- 📌 相比之前，新函数只用了一层for循环就完成了任务，代码变得更精练了。  ^2009032-7IY46JGzo
    - 💭 这里有一个问题，product是会把所有的组合都预先计算出来吗？这样的话内存不会爆掉？如果是产生枚举的迭代器，这样才是正确的做法吧。
    - ⏱ 2023-06-14 19:52:40
   
## 7.1 基础知识

### 划线评论
- 📌 当我们为函数参数设置了默认值，不强制要求调用方提供这些参数以后，会引入另一件麻烦事儿：无法严格区分调用方是不是真的提供了这个默认参数。  ^2009032-7IZfqzD5D
    - 💭 我没明白为啥要严格区分这种情况呢？
    - ⏱ 2023-06-15 14:32:10
   
# 本书评论
