---
doc_type: weread-highlights-reviews
bookId: "3300018868"
author: 朱雷
cover: https://cdn.weread.qq.com/weread/cover/68/3300018868/t7_3300018868.jpg
reviewCount: 16
noteCount: 144
isbn: 9787115584045
category: 计算机-编程设计
lastReadDate: 2024-02-27
---
# 元数据
> [!abstract] Python工匠：案例、技巧与工程实践
> - ![ Python工匠：案例、技巧与工程实践|200](https://cdn.weread.qq.com/weread/cover/68/3300018868/t7_3300018868.jpg)
> - 书名： Python工匠：案例、技巧与工程实践
> - 作者： 朱雷
> - 简介： 本书基于受欢迎的“Python工匠”系列开源文章。全书从工程实践角度出发，通过剖析核心知识、展示典型案例与总结实用技巧，帮助大家系统进阶Python，写好工程代码，做好实践项目。  本书共计13章，分为五大部分：变量与基础类型、语法结构、函数与装饰器、面向对象编程、总结与延伸，涵盖Python编程的方方面面。本书的写作方式别具一格，核心知识点都会通过三大板块来阐述：基础知识、案例故事、编程建议。其中基础知识帮助大家快速回顾Python基础；案例故事由作者经历的编程项目与案例改编而来，兼具实战性与趣味性；编程建议以大家喜闻乐见的条目式知识点呈现，短小精悍，可直接应用于自己的编程实践中。
> - 出版时间 2022-03-01 00:00:00
> - ISBN： 9787115584045
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社有限公司

# 高亮划线

## 为什么写这本书


- 📌 在接手了几个被众人称为“坑”的老项目，或是亲手写了一些无人敢接手的代码后；在整日忙着修bug，每写一个新功能就引入三个新bug后……夜深人静之时，坐在电脑前埋头苦干的我们总有那么一些瞬间会突然意识到：编程最初带给我们的快乐已悄然远去，写代码这件事现在变得有些痛苦。更有甚者，一想到项目里的烂代码，每天起床后最想干的一件事就是辞职。 ^3300018868-5-684-849
    - ⏱ 2023-05-11 16:24:00 

- 📌 第二部分：与Python语言强相关的知识，比如自定义容器类型来改善代码、在恰当的时机抛出异常、活用生成器改善循环、用装饰器设计地道的API，等等。 ^3300018868-5-1617-1690
    - ⏱ 2024-01-11 11:48:21 
## 第1章 变量与注释


- 📌 好的变量和注释并非为计算机而写，而是为每个阅读代码的人而写（当然也包括你自己）。 ^3300018868-12-1786-1826
    - ⏱ 2023-05-24 23:18:49 
## 1.1 基础知识


- 📌 动态类型 ^3300018868-13-733-737
    - ⏱ 2023-05-24 23:19:02 

- 📌 除了上面的普通解包外，Python还支持更灵活的动态解包语法。只要用星号表达式（*variables）作为变量名，它便会贪婪￼地捕获多个值对象，并将捕获到的内容作为列表赋值给variables。 ^3300018868-13-1731-1991
    - ⏱ 2023-05-24 23:19:49 
 

- 📌 动态类型所带来的缺点是代码的可读性会因此大打折扣。 ^3300018868-13-3809-3834
    - ⏱ 2023-05-24 23:21:30 

- 📌 相比编写Sphinx格式文档，我其实更推荐使用类型注解，因为它是Python的内置功能，而且正在变得越来越流行。 ^3300018868-13-4731-4787
    - ⏱ 2023-05-24 23:22:05 

- 📌 因此，我强烈建议在多人参与的中大型Python项目里，至少使用一种类型注解方案——Sphinx格式文档或官方类型注解都行。能直接看到变量类型的代码，总是会让人更安心。 ^3300018868-13-5950-6059
    - ⏱ 2023-05-24 23:22:38 

- 📌 计算机科学领域只有两件难事：缓存失效和命名。——Phil Karlton ^3300018868-13-6914-6982
    - ⏱ 2023-05-24 23:22:57 

- 📌 为了让不同开发者写出的代码风格尽量保持统一，Python制定了官方的编码风格指南：PEP 8。 ^3300018868-13-7391-7438
    - ⏱ 2023-05-24 23:23:20 
 

- 📌 对于不再需要的代码，我们应该直接把它们删掉，而不是注释掉。 ^3300018868-13-15089-15118
    - ⏱ 2023-05-24 23:26:17 

- 📌 在编写注释时，新手常犯的另一类错误是用注释复述代码。 ^3300018868-13-15264-15290
    - ⏱ 2023-05-24 23:26:26 

- 📌 指引性注释 ^3300018868-13-15811-15823
    - ⏱ 2023-05-24 23:26:46 
## 1.3 编程建议


- 📌 在组织代码时，我们应该谨记：总是从代码的职责出发，而不是其他东西。 ^3300018868-15-2604-2663
    - ⏱ 2023-05-24 23:29:18 

- 📌 直接翻译业务逻辑的代码，大多不是好代码。优秀的程序设计需要在理解原需求的基础上，恰到好处地抽象，只有这样才能同时满足可读性和可扩展性方面的需求。抽象有许多种方式，比如定义新函数、定义新类型，“定义一个临时变量”是诸多方式里不太起眼的一个，但用得恰当的话效果也很巧妙。 ^3300018868-15-4472-4605
    - ⏱ 2023-05-24 23:29:47 

- 📌 Python之禅：显式优于隐式 ^3300018868-15-9453-9468
    - ⏱ 2023-05-24 23:30:53 
## 第2章 数值与字符串

 

- 📌 字节串类型（bytes） ^3300018868-17-1440-1452
    - ⏱ 2023-05-25 16:29:04 
## 2.1 基础知识


- 📌 decimal ^3300018868-18-2007-2014
    - ⏱ 2023-05-25 16:30:36 

- 📌 任何问题应有一种且最好只有一种显而易见的解决方法。 ^3300018868-18-4865-4890
    - ⏱ 2023-05-25 16:33:23 

- 📌 （1）C语言风格的基于百分号%的格式化语句：'Hello, %s' % 'World'。（2）新式字符串格式化（str.format）方式（Python 2.6新增）："Hello,{}".format ('World')。（3）f-string字符串字面量格式化表达式（Python 3.6新增）：name ='World'; f'Hello, {name}'。 ^3300018868-18-5171-5413
    - ⏱ 2024-01-24 16:33:49 

- 📌 虽然年轻的f-string抢走了str.format的大部分风头，但后者仍有着自己的独到之处。 ^3300018868-18-6511-6558
    - ⏱ 2023-05-25 16:35:02 

- 📌 （1）字符串：我们最常挂在嘴边的“普通字符串”，有时也被称为文本（text），是给人看的，对应Python中的字符串（str）类型。str使用Unicode标准，可通过.encode()方法编码为字节串。（2）字节串：有时也称“二进制字符串”（binary string），是给计算机看的，对应Python中的字节串（bytes）类型。bytes一定包含某种真正的字符串编码格式（默认为UTF-8），可通过.decode()解码为字符串。 ^3300018868-18-10058-10384
    - ⏱ 2023-05-25 17:03:03 
## 2.2 案例故事


- 📌 说到有意义的数字，大家最先想到的一般是“常量”（constant）。但Python里没有真正的常量类型，人们一般会把大写字母全局变量当“常量”来用。 ^3300018868-19-2012-2086
    - ⏱ 2024-01-29 16:54:01 

- 📌 这种因为输入错误导致的bug并不少见，而且隐蔽性特别强。 ^3300018868-19-3227-3255
    - ⏱ 2023-05-25 19:30:26 

- 📌 SQLAlchemy ^3300018868-19-5619-5629
    - ⏱ 2023-05-25 19:31:28 
## 2.4 总结


- 📌 在看到一些写代码的“经验之谈”时，你最好抱着怀疑精神，因为Python语言进化得特别快，稍不留神，以往的经验就会过时。如果需要验证某个“经验之谈”，dis和timeit两个优秀的工具可以帮到你：前者能让你直接查看编译后的字节码，后者则能让你方便地做性能测试。保持怀疑、多多实验，有助于你成长为更优秀的程序员。 ^3300018868-21-698-852
    - ⏱ 2023-05-26 13:40:23 
## 第3章 容器类型


- 📌 列表、元组、字典、集合 ^3300018868-22-608-619
    - ⏱ 2023-05-26 13:41:43 
## 3.1 基础知识


- 📌 enumerate()适用于任何“可迭代对象”，因此它不光可以用于列表，还可以用于元组、字典、字符串等其他对象。 ^3300018868-23-2001-2057
    - ⏱ 2024-01-30 11:14:54 

- 📌 列表推导式（list comprehension） ^3300018868-23-2828-2860
    - ⏱ 2023-05-26 13:44:08 

- 📌 · 可变（mutable）：列表、字典、集合。· 不可变（immutable）：整数、浮点数、字符串、字节串、元组。 ^3300018868-23-3452-3593
    - ⏱ 2023-05-26 13:44:34 

- 📌 答案其实没有你想得那么“复杂”——Python在进行函数调用传参时，采用的既不是值传递，也不是引用传递，而是传递了“变量所指对象的引用”（pass-by-object-reference）。 ^3300018868-23-6230-6325
    - ⏱ 2024-01-30 11:16:27 

- 📌 由此可见，Python的函数调用不能简单归类为“值传递”或者“引用传递”，一切行为取决于对象的可变性。 ^3300018868-23-8054-8105
    - ⏱ 2023-05-27 23:31:41 

- 📌 具名元组（namedtuple） ^3300018868-23-11449-11472
    - ⏱ 2024-01-30 11:18:06 

- 📌 不过，如果只是“提供默认值的读取操作”，其实可以直接使用字典的.get()方法。 ^3300018868-23-14870-14910
    - ⏱ 2023-05-27 23:34:10 

- 📌 Python里的字典在底层使用了哈希表（hash table）数据结构。 ^3300018868-23-18173-18235
    - ⏱ 2024-01-30 11:24:03 

- 📌 frozenset ^3300018868-23-21697-21706
    - ⏱ 2024-01-30 11:26:21 

- 📌 对象的可哈希性 ^3300018868-23-24164-24171
    - ⏱ 2023-05-31 19:21:47 

- 📌 首先，那些不可变的内置类型都是可哈希的： ^3300018868-23-24523-24543
    - ⏱ 2023-05-31 19:22:17 

- 📌 而可变的内置类型都无法正常计算哈希值： ^3300018868-23-24779-24798
    - ⏱ 2023-05-31 19:22:22 

- 📌 （1）所有的不可变内置类型，都是可哈希的，比如str、int、tuple、frozenset等；（2）所有的可变内置类型，都是不可哈希的，比如dict、list等；（3）对于不可变容器类型(tuple, frozenset)，仅当它的所有成员都不可变时，它自身才是可哈希的；（4）用户定义的类型默认都是可哈希的。 ^3300018868-23-25492-25735
    - ⏱ 2023-05-31 19:22:54 
## 3.3 编程建议


- 📌 按需生成，而不是一次性返回 ^3300018868-25-1544-1557
    - ⏱ 2024-01-30 11:38:08 

- 📌 生成器（generator）是Python里的一种特殊的数据类型。顾名思义，它是一个不断给调用方“生成”内容的类型。 ^3300018868-25-1760-1825
    - ⏱ 2023-05-31 19:25:53 

- 📌 这个性能差距与列表的底层实现有关。Python在实现列表时，底层使用了数组（array）数据结构。这种结构最大的一个特点是，当你在数组中间插入新成员时，该成员之后的其他成员都需要移动位置，该操作的平均时间复杂度是O(n)。因此，在列表的头部插入成员，比在尾部追加要慢得多（后者的时间复杂度为O（1））。 ^3300018868-25-5909-6086
    - ⏱ 2024-01-30 11:41:21 

- 📌 要实现合并功能，需要用到双星号**运算符来做解包操作。在字典中使用**dict_obj表达式，可以动态解包dict_obj字典的所有内容，并与当前字典合并： ^3300018868-25-9419-9497
    - ⏱ 2023-05-31 19:29:47 

- 📌 合理利用*和**运算符，可以帮助我们高效构建列表与字典对象。 ^3300018868-25-10232-10262
    - ⏱ 2023-05-31 19:30:07 

- 📌 别在遍历列表时同步修改 ^3300018868-25-11641-11653
    - ⏱ 2023-05-31 19:30:56 
## 4.1 基础知识


- 📌 当我们编写分支时，第一件要注意的事情，就是不要显式地和布尔值做比较 ^3300018868-28-1025-1058
    - ⏱ 2024-01-30 19:36:05 
 

- 📌 假如一个类同时定义了__len__和__bool__两个方法，解释器会优先使用__bool__方法的执行结果。 ^3300018868-28-6325-6380
    - ⏱ 2023-05-31 19:36:55 

- 📌 对于从-5到256的这些常用小整数，Python会将它们缓存在内存里的一个数组中。当你的程序需要用到这些数字时，Python不会创建任何新的整型对象，而是会返回缓存中的对象。这样能为程序节约可观的内存。 ^3300018868-28-9006-9107
    - ⏱ 2023-05-31 19:43:59 
## 4.3 编程建议


- 📌 提前返回 ^3300018868-30-1539-1543
    - ⏱ 2023-06-07 16:30:31 

- 📌 别写太复杂的条件表达式 ^3300018868-30-2501-2512
    - ⏱ 2023-06-07 16:31:06 
 

- 📌 在Python的众多内置函数中，有两个特别适合在构建条件表达式时使用，它们就是all()和any()。这两个函数接收一个可迭代对象作为参数，返回一个布尔值结果。 ^3300018868-30-7129-7209
    - ⏱ 2023-06-07 16:31:42 

- 📌 出现这个结果的原因是：and运算符的优先级高于or。因此在Python看来，上面第二个表达式实际上等同于True or (False and False)，所以最终结果是True而不是False。 ^3300018868-30-8384-8482
    - ⏱ 2023-06-07 16:32:34 
 

- 📌 因为or计算的是变量的布尔真假值，所以不光是None，0、[]、{}以及其他所有布尔值为假的东西，都会在or运算中被忽略： ^3300018868-30-9651-9712
    - ⏱ 2023-06-07 16:33:08 
## 第5章 异常与错误处理


- 📌 同时我开始认识到，错误处理不是什么编程的额外负担，它和所有其他工作一样重要。如果能善用异常机制优雅地处理好程序里的错误，我们就能用更少、更清晰的代码，写出更健壮的程序。 ^3300018868-32-1330-1414
    - ⏱ 2024-02-01 09:18:10 
## 5.1 基础知识


- 📌 LBYL（look before you leap） ^3300018868-33-1633-1659
    - ⏱ 2023-06-07 19:29:29 

- 📌 EAFP（easier to ask for forgiveness than permission） ^3300018868-33-1856-1907
    - ⏱ 2023-06-07 19:29:38 

- 📌 一个显而易见的原因是，EAFP风格的代码通常会更精简。因为它不要求开发者用分支完全覆盖各种可能出错的情况，只需要捕获可能发生的异常即可。另外，EAFP风格的代码通常性能也更好。比如在这个例子里，假如你每次都用字符串'73'来调用函数，这两种风格的代码在操作流程上会有如下区别。（1）LBYL：每次调用都要先进行额外的isinstance和isdigit判断。（2） EAFP：每次调用直接执行转换，返回结果。 ^3300018868-33-2756-3018
    - ⏱ 2023-06-07 19:30:01 

- 📌 通过with实现的“忽略异常”功能，主要利用了上下文管理器的__exit__方法。 ^3300018868-33-14759-14800
    - ⏱ 2024-02-01 11:36:30 

- 📌 @contextmanager位于内置模块contextlib下，它可以把任何一个生成器函数直接转换为一个上下文管理器。 ^3300018868-33-15870-15930
    - ⏱ 2024-02-01 11:37:17 
## 5.2 案例故事


- 📌 · 永远只捕获那些可能会抛出异常的语句块；· 尽量只捕获精确的异常类型，而不是模糊的Exception；· 如果出现了预期外的异常，让程序早点儿崩溃也未必是件坏事。 ^3300018868-34-3326-3470
    - ⏱ 2023-06-07 19:40:58 

- 📌 异常类与模块抽象级别不一致导致 ^3300018868-34-6841-6856
    - ⏱ 2024-02-01 11:39:48 

- 📌 让模块只抛出与当前抽象级别一致的异常；· 在必要的地方进行异常包装与转换。 ^3300018868-34-7121-7190
    - ⏱ 2023-06-07 19:42:11 
## 5.3 编程建议


- 📌 在数据校验这块，pydantic模块是一个不错的选择。如果用它来做校验，上面的代码可以改写成代码清单5-7。 ^3300018868-35-3503-3557
    - ⏱ 2024-02-01 11:56:09 

- 📌 assert是一个专供开发者调试程序的关键字。它所提供的断言检查，可以在执行Python时使用-O选项直接跳过： ^3300018868-35-8213-8269
    - ⏱ 2023-06-08 09:44:18 

- 📌 unset命令的例子体现出了一种程序设计技巧：在设计API时，如果稍微调整一下思考问题的角度，修改API的抽象定义，那么那些原本需要处理的错误，也许就会神奇地消失。假如API不抛出错误，调用方也就不需要处理错误，这会大大减轻大家的心智负担。 ^3300018868-35-9508-9628
    - ⏱ 2023-06-08 09:44:57 
 
## 第6章 循环与可迭代对象


- 📌 可迭代对象 ^3300018868-37-1504-1509
    - ⏱ 2023-06-08 11:04:36 
## 6.1 基础知识


- 📌 迭代器最鲜明的特征是：不断对它执行next()函数会返回下一次迭代结果。 ^3300018868-38-1673-1709
    - ⏱ 2023-06-08 11:06:20 

- 📌 区分迭代器与可迭代对象 ^3300018868-38-5389-5400
    - ⏱ 2024-02-01 15:08:17 

- 📌 · 可迭代对象不一定是迭代器，但迭代器一定是可迭代对象；· 对可迭代对象使用iter()会返回迭代器，迭代器则会返回其自身；· 每个迭代器的被迭代过程是一次性的，可迭代对象则不一定；· 可迭代对象只需要实现__iter__方法，而迭代器要额外实现__next__方法。 ^3300018868-38-7413-7640
    - ⏱ 2024-02-01 15:09:01 

- 📌 enumerate()是Python的一个内置函数，它接收一个可迭代对象作为参数，返回一个不断生成(当前下标,当前元素)的新可迭代对象。 ^3300018868-38-9622-9690
    - ⏱ 2024-02-01 15:10:10 

- 📌 itertools ^3300018868-38-10940-10949
    - ⏱ 2024-02-01 15:11:21 

- 📌 itertools ^3300018868-38-14714-14723
    - ⏱ 2023-06-14 19:55:13 
## 6.2 案例故事


- 📌 小R在代码里所使用的文件读取方式，可谓Python里的“标准做法”：首先用with open (fine_name)上下文管理器语法获得一个文件对象，然后用for循环迭代它，逐行获取文件里的内容。为什么这种文件读取方式会成为标准？这是因为它有两个好处：（1）with上下文管理器会自动关闭文件描述符；（2）在迭代文件对象时，内容是一行一行返回的，不会占用太多内存。 ^3300018868-39-2006-2301
    - ⏱ 2023-06-14 19:57:44 
## 6.3 编程建议


- 📌 因此在平时，你需要将生成器（迭代器）的“可被一次性耗尽”特点铭记于心，避免写出由它所导致的bug。假如要重复使用一个生成器，可以调用list()函数将它转成列表后再使用。 ^3300018868-40-5234-5319
    - ⏱ 2023-06-14 20:06:15 

- 📌 除了生成器函数、生成器表达式以外，人们还常常忽略内置的map()、filter()函数也会返回一个一次性的迭代器对象。在使用这些函数时，也请务必当心。 ^3300018868-40-5489-5564
    - ⏱ 2023-06-14 20:06:23 
## 第7章 函数


- 📌 而消除重复代码，只是函数所提供给我们的众多好处之一。如果以它为起点，向四周继续发散，你会发现更多有趣的编程概念，包括高阶函数（higher-order function）、闭包（closure）、装饰器（decorator），等等。深入理解和掌握这些概念，是成为一名合格程序员的必经之路。 ^3300018868-42-762-984
    - ⏱ 2023-06-14 20:09:01 

- 📌 函数在Python中是一等对象，这意味着我们可以把函数自身作为函数参数来使用。 ^3300018868-42-1471-1510
    - ⏱ 2024-02-19 09:39:05 
## 7.1 基础知识


- 📌 之所以出现这个问题，是因为Python函数的参数默认值只会在函数定义阶段被创建一次，之后不论再调用多少次，函数内拿到的默认值都是同一个对象。 ^3300018868-43-1362-1458
    - ⏱ 2023-06-15 14:15:26 

- 📌 因此，熟悉Python的程序员通常不会将可变类型作为参数默认值。 ^3300018868-43-1921-1953
    - ⏱ 2024-02-19 09:42:27 

- 📌 为了规避这个问题，使用None来替代可变类型默认值是比较常见的做法 ^3300018868-43-2020-2053
    - ⏱ 2023-06-15 14:30:58 
 

- 📌 好的函数设计一定是简单的，这种简单体现在各个方面。返回多种类型明显违反了简单原则。这种做法不光会给函数本身增加不必要的复杂度，还会提高用户理解和使用函数的成本。 ^3300018868-43-6827-6907
    - ⏱ 2023-06-15 14:34:02 

- 📌 从上面的分析来看，适合返回None的函数需要满足以下两个特点：（1）函数的名称和参数必须表达“结果可能缺失”的意思；（2）如果函数执行无法产生结果，调用方也不关心具体原因。 ^3300018868-43-9232-9376
    - ⏱ 2024-02-19 09:49:26 

- 📌 “单一出口”的由来在写这部分内容时，我特意查询了“单一出口”原则的历史，以下是我的发现。在几十年前，汇编与FORTRAN语言流行的年代，编程语言拥有令人头疼的灵活性，你可以用各种花样在代码内随意跳转，这导致程序员很容易写出各种难以调试的代码。为了解决这个问题，著名计算机科学家Dijkstra提出了“单一入口，单一出口”（Single Entry, Single Exit）原则。在这个原则中，“单一出口”的意思是：函数（子程序）应该只从同一个地方跳出。这样一来事情就很明朗了。在现代编程语言里，无论函数内部有多少个return语句，函数的出口都是统一的——通往上层调用栈，所以这完全不属于最初的“单一出口”原则所担心的范围。即使后来“单一出口”原则发展出了别的含义，它也只针对一些特定的编程语言、编程场景有意义。比如在特定环境下，不恰当的返回会导致程序资源泄露等问题，所以要把返回统一起来管理。但在Python中，“单一出口原则建议函数只写一个return”只能算是一种误读，在“单一出口”和“多多返回”之间，我们完全可以选择可读性更强的那个。 ^3300018868-43-12433-13099
    - ⏱ 2023-06-15 14:37:55 

- 📌 lru_cache() ^3300018868-43-15380-15391
    - ⏱ 2023-06-15 14:39:12 
## 7.2 案例故事


- 📌 在函数式编程（functional programming）领域，有一个术语纯函数（pure function）。它最大的特点是，假如输入参数相同，输出结果也一定相同，不受任何其他因素影响。换句话说，纯函数是一种无状态的函数。 ^3300018868-44-412-577
    - ⏱ 2023-06-15 14:47:21 

- 📌 闭包（closure）是编程语言领域里的一个专有名词。简单来说，闭包是一种允许函数访问已执行完成的其他函数里的私有变量的技术，是为函数增加状态的另一种方式。 ^3300018868-44-6420-6505
    - ⏱ 2023-06-15 14:49:09 
## 7.3 编程建议


- 📌 别写太复杂的函数 ^3300018868-45-579-587
    - ⏱ 2023-06-15 14:54:08 

- 📌 分层思想 ^3300018868-45-4351-4355
    - ⏱ 2023-06-15 14:56:30 

- 📌 对于这种进行简单操作的匿名函数，我们其实完全可以用operator模块里的函数来替代。比如使用operator.itemgetter()就可以直接实现“获取某个key的值”操作： ^3300018868-45-15083-15172
    - ⏱ 2024-02-19 11:13:37 

- 📌 当你确实想要编写lambda函数时，请尝试问自己一个问题：“这个功能用def写一个普通函数是不是更合适？”尤其当需求比较复杂时，千万别试着把大段逻辑糅进一个巨大的匿名函数里。请记住，没什么特殊功能是lambda能做而普通函数做不到的。 ^3300018868-45-15857-15974
    - ⏱ 2024-02-19 11:14:08 
## 7.4 总结


- 📌 最后我想说的是，虽然函数可以消除重复代码，但绝不能只把它看成一种复用代码的工具。函数最重要的价值其实是创建抽象，而提供复用价值甚至可以算成抽象所带来的一种“副作用”。 ^3300018868-46-769-852
    - ⏱ 2024-02-19 11:16:20 
## 8.1 基础知识


- 📌 装饰器是一种通过包装目标函数来修改其行为的特殊高阶函数，绝大多数装饰器是利用函数的闭包原理实现的。 ^3300018868-48-495-551
    - ⏱ 2023-08-21 17:34:35 

- 📌 正因为如此，在编写装饰器时，切记使用@functools.wraps()来修饰包装函数。 ^3300018868-48-6850-6894
    - ⏱ 2024-02-19 11:26:18 

- 📌 如果按装饰器用于替换原函数的对象类型来分类，类实现的装饰器可分为两种，一种是“函数替换”，另一种是“实例替换”。 ^3300018868-48-10276-10332
    - ⏱ 2024-02-19 11:28:39 
## 8.2 编程建议


- 📌 装饰器带来的改变，主要在于把修改函数的调用提前到了函数定义处，而这一点儿位置上的小变化，重塑了读者理解代码的整个过程。 ^3300018868-49-652-711
    - ⏱ 2023-08-21 19:20:13 

- 📌 所以，装饰器的优势并不在于它提供了动态修改函数的能力，而在于它把影响函数的装饰行为移到了函数头部，降低了代码的阅读与理解成本。 ^3300018868-49-922-985
    - ⏱ 2024-02-19 11:41:45 

- 📌 Python中的元类（metaclass）是一种特殊的类。就像类可以控制实例的创建过程一样，元类可以控制类的创建过程。通过元类，我们能实现各种强大的功能。 ^3300018868-49-2413-2516
    - ⏱ 2024-02-19 11:43:05 

- 📌 装饰器模式属于面向对象领域。实现装饰器模式，需要具备以下关键要素：· 设计一个统一的接口；· 编写多个符合该接口的装饰器类，每个类只实现一个简单的功能；· 通过组合的方式嵌套使用这些装饰器类；· 通过类和类之间的层层包装来实现复杂的功能。 ^3300018868-49-4376-4619
    - ⏱ 2024-02-19 11:44:27 

- 📌 因为归根结底，装饰器其实只是一类特殊的API，一种提供服务的方式。比起把所有核心逻辑都放在装饰器内，不如让装饰器里只有一层浅浅的包装层，而把更多的实现细节放在其他函数或类中。 ^3300018868-49-6889-6976
    - ⏱ 2024-02-19 11:45:32 
## 第9章 面向对象编程


- 📌 我们常把类里定义的函数称作方法 ^3300018868-51-1504-1538
    - ⏱ 2024-02-19 11:53:16 

- 📌 @classmethod、@staticmethod等装饰器来定义特殊方法 ^3300018868-51-1560-1597
    - ⏱ 2023-08-21 19:21:43 
## 9.1 基础知识


- 📌 私有属性是“君子协定” ^3300018868-52-701-712
    - ⏱ 2024-02-19 11:54:18 

- 📌 Python没有严格意义上的私有属性，应该就是遵循了这条哲学的结果。 ^3300018868-52-2178-2212
    - ⏱ 2024-02-19 11:55:04 

- 📌 不过，@property装饰器模糊了属性和方法间的界限，使用它，你可以把方法通过属性的方式暴露出来。 ^3300018868-52-8156-8206
    - ⏱ 2024-02-19 11:57:35 

- 📌 通过__subclasshook__类方法，我们可以定制抽象类的子类判断逻辑。这种子类化形式只关心结构，不关心真实继承关系，所以常被称为“结构化子类”。 ^3300018868-52-20050-20126
    - ⏱ 2024-02-19 14:21:26 

- 📌 在实际项目里，你应该非常谨慎地对待多重继承，因为它很容易催生出一些复杂的继承关系，进而导致代码难以维护。假如你发现自己在实现某个功能时，必须使用多重继承，而且必须用MRO算法来精心设计方法间的覆盖关系，此时你应该停下来，喝口水，深吸一口气，重新思考一遍自己想要解决的问题。 ^3300018868-52-26218-26354
    - ⏱ 2024-02-19 14:25:32 

- 📌 和Python里的其他功能相比，元类是个相当高级的语言特性。通常来说，除非要开发一些框架类工具，否则你在日常工作中根本不需要用到元类。 ^3300018868-52-31323-31390
    - ⏱ 2024-02-19 14:28:05 
## 9.2 案例故事


- 📌 但粗心大意只是表面原因。在开发软件时，我们不能指望程序员能够事事考虑得十全十美，永远记得自己写过的每一段代码逻辑，这根本就不现实。 ^3300018868-53-8764-8829
    - ⏱ 2024-02-19 15:21:08 
## 9.3 编程建议


- 📌 多态（polymorphism） ^3300018868-54-2175-2198
    - ⏱ 2024-02-19 15:36:16 

- 📌 作为惯例，__init__实例化方法应该总是放在类的最前面，__new__方法同理。 ^3300018868-54-6386-6428
    - ⏱ 2024-02-19 15:37:27 

- 📌 公有方法应该放在类的前面，因为它们是其他模块调用类的入口，是类的门面，也是所有人最关心的内容。以_开头的私有方法，大部分是类自身的实现细节，应该放在靠后的位置。 ^3300018868-54-6457-6537
    - ⏱ 2024-02-19 15:37:34 
## 第10章 面向对象设计原则（上）


- 📌 · S：single responsibility principle（单一职责原则，SRP）。 ^3300018868-56-2093-2141
    - ⏱ 2024-02-19 15:43:21 

- 📌 · O：open-closed principle（开放–关闭原则，OCP）。 ^3300018868-56-2172-2211
    - ⏱ 2024-02-19 15:43:25 

- 📌 · L：Liskov substitution principle（里式替换原则，LSP）。 ^3300018868-56-2242-2288
    - ⏱ 2024-02-19 15:43:30 

- 📌 · I：interface segregation principle（接口隔离原则，ISP）。 ^3300018868-56-2319-2367
    - ⏱ 2024-02-19 15:43:35 

- 📌 · D：dependency inversion principle（依赖倒置原则，DIP）。 ^3300018868-56-2398-2445
    - ⏱ 2024-02-19 15:43:39 
## 10.2 SRP：单一职责原则


- 📌 单一职责原则 ^3300018868-58-383-389
    - ⏱ 2024-02-19 16:50:58 

- 📌 函数同样可以做到“单一职责”单一职责是面向对象领域的设计原则，通常用来形容类。而在Python中，单一职责的适用范围不限于类——通过定义函数，我们同样能让上面的代码符合单一职责原则。 ^3300018868-58-8097-8226
    - ⏱ 2024-02-19 16:52:14 
## 10.3 OCP：开放-关闭原则


- 📌 但数据驱动也有一个缺点：它的可定制性不如其他两种方式。举个例子，假如我想以“链接是否以某个字符串结尾”来进行过滤，现在的数据驱动代码就做不到。影响每种方案可定制性的根本原因在于，各方案所处的抽象级别不一样。比如，在依赖注入方案下，我选择抽象的内容是“条目过滤行为”；而在数据驱动方案下，抽象内容则是“条目过滤行为的有效站点地址”。很明显，后者的抽象级别更低，关注的内容更具体，所以灵活性不如前者。 ^3300018868-59-11833-12112
    - ⏱ 2024-02-19 16:56:26 
## 第11章 面向对象设计原则（下）


- 📌 LSP是一条用来约束继承的设计原则。我在第9章中说过，继承是一种既强大又危险的技术，要设计出合理的继承关系绝非易事。 ^3300018868-61-895-953
    - ⏱ 2024-02-19 17:08:39 
## 11.1 LSP：里式替换原则


- 📌 这里用一种更通俗的方式来描述LSP：LSP认为，所有子类（派生类）对象应该可以任意替代父类（基类）对象使用，且不会破坏程序原本的功能。 ^3300018868-62-850-917
    - ⏱ 2024-02-19 17:09:54 

- 📌 在编写代码时，假如你发现自己的设计违反了LSP，就需要竭尽所能解决这个问题。有时你得在父类中引入新的异常类型，有时你得尝试用组合替代继承，有时你需要调整子类的方法参数。总之，只要深入思考类与类之间的关系，总会找到正确的解法。 ^3300018868-62-14994-15106
    - ⏱ 2024-02-19 17:18:39 
## 11.2 DIP：依赖倒置原则


- 📌 高层模块不应该依赖低层模块，二者都应该依赖抽象。 ^3300018868-63-783-814
    - ⏱ 2024-02-19 17:19:39 

- 📌 如果测试代码过分关心类的内部实现，就会变得很脆弱。 ^3300018868-63-6953-6978
    - ⏱ 2024-02-19 17:23:08 

- 📌 正因为如此，mock应该总是被当作一种应急的技术，而不是一种低成本、让单元测试能快速开展的手段。 ^3300018868-63-7185-7233
    - ⏱ 2024-02-19 17:23:31 

- 📌 只有对代码中那些容易变化的东西进行抽象，才能获得最大的收益。 ^3300018868-63-14194-14224
    - ⏱ 2024-02-19 17:25:49 
## 11.3 ISP：接口隔离原则


- 📌 接口是一种非常有用的设计工具，为了更好地发挥它的能力，ISP对如何使用接口提出了要求：客户（client）不应该依赖任何它不使用的方法。 ^3300018868-64-621-715
    - ⏱ 2024-02-19 17:26:36 

- 📌 当你认识到ISP带来的种种好处后，很自然地会养成写小类、小接口的习惯。在现实世界里，其实已经有很多小而精的接口设计可供参考，比如： ^3300018868-64-8146-8211
    - ⏱ 2024-02-19 17:29:09 
## 12.1 基础知识


- 📌 假如其他人能通过复制repr()的字符串结果直接创建一个同样的对象，就再好不过了。 ^3300018868-67-1551-1592
    - ⏱ 2024-02-20 14:02:05 
## 12.3 编程建议


- 📌 正因为如此，依赖__del__方法来做一些清理资源、释放锁、关闭连接池之类的关键工作，其实非常危险。因为你创建的任何对象，完全有可能因为某些原因一直都不被作为垃圾回收。 ^3300018868-69-5775-5859
    - ⏱ 2024-02-26 13:59:17 
## 13.2 单元测试简介


- 📌 在单元测试领域，有一种常用的编写测试代码的技术：表驱动测试（table-driven testing）。 ^3300018868-73-6180-6258
    - ⏱ 2024-02-27 12:58:17 

- 📌 这类被许多单元测试依赖、需要重复使用的对象，常被称为fixture。 ^3300018868-73-9844-9878
    - ⏱ 2024-02-27 12:59:17 

- 📌 pytest里的fixture可以使用五种作用域，它们的区别如下。（1） function（函数）：默认作用域，结果会在每个测试函数结束后销毁。（2） class（类）：结果会在执行完类里的所有测试方法后销毁。（3） module（模块）：结果会在执行完整个模块的所有测试后销毁。（4） package（包）：结果会在执行完整个包的所有测试后销毁。（5）session（测试会话）：结果会在测试会话（也就是一次完整的pytest执行过程）结束后销毁。 ^3300018868-73-12164-12534
    - ⏱ 2024-02-27 12:59:55 
## 13.3 有关单元测试的建议


- 📌 难测试的代码就是烂代码 ^3300018868-74-4841-4852
    - ⏱ 2024-02-27 13:01:26 
## 13.4 总结


- 📌 无论如何，永远不要停止学习。 ^3300018868-75-1047-1061
    - ⏱ 2024-02-27 13:02:41 
# 读书笔记

## 为什么写这本书

### 划线评论
- 📌 生成器  ^2009032-7I880FyLf
    - 💭 应该是迭代器吧？
    - ⏱ 2023-05-11 16:25:22
   
## 获取本书示例代码

### 划线评论
- 📌 作为一本编程图书，本书包含许多代码示例。如果你想在自己的电脑上运行这些代码，做一些简单的修改和测试，可以访问本书的图灵社区主页[插图]下载书中所有代码示例源文件。  ^2009032-7IiDaRc7V
    - 💭 为啥不放在GitHub，放在图灵的社区？？？
    - ⏱ 2023-05-18 14:07:55
   
## 第1章 变量与注释

### 划线评论
- 📌 从计算机的角度来看，变量（variable）是用来从内存找到某个东西的标记。它叫“阿猫”“阿狗”还是“张三”“李四”，都无所谓。注释同样如此，计算机一点儿都不关心你的注释写得是否通顺，用词是否准确，因为它在执行代码时会忽略所有的注释。  ^2009032-7O8wwYAKZ
    - 💭 pretty code is not for maching, is for the man who will read it
    - ⏱ 2024-01-11 12:01:15
   
## 1.1 基础知识

### 划线评论
- 📌 动态解包  ^2009032-7O8wIJ0cY
    - 💭 其实我使用python，你要解包，必须要先知道data的数据结构才可以。
    - ⏱ 2024-01-11 12:04:08

### 划线评论
- 📌 单下划线变量名_  ^2009032-7IslfFywe
    - 💭 dummy value
    - ⏱ 2023-05-24 23:20:58

### 划线评论
- 📌 为变量命名要结合代码情境和上下文  ^2009032-7O8Sk8mVL
    - 💭 局部变量的名称可以不用太长，结合上下文很容易看懂。
    - ⏱ 2024-01-11 17:34:00

### 划线评论
- 📌 如果你苦思冥想都想不出一个合适的名字，请打开GitHub[插图]，到其他人的开源项目里找找灵感吧  ^2009032-7O8SsBXnU
    - 💭 这个应该更新成：打开ChatGPT，让它给你一些建议吧。
    - ⏱ 2024-01-11 17:36:05
   
## 1.2 案例故事

### 划线评论
- 📌 这些变化让整段代码变得更易读，也让整个算法变得更好理解。  ^2009032-7O8SErpsy
    - 💭 例子有点夸张，大部分的面试官应该还是可以看懂的。实在看不太懂，直接跑一下代码应该也是可以的吧。
    - ⏱ 2024-01-11 17:39:00
   
## 1.3 编程建议

### 划线评论
- 📌 这样的代码就像删掉赘语的句子，变得更精练、更易读。所以，不必为了那些未来可能出现的变动，牺牲代码此时此刻的可读性。如果以后需要定义变量，那就以后再做吧！  ^2009032-7OsxFk0gF
    - 💭 我有个问题：这种情况下，我打断点排查问题比较麻烦。
    - ⏱ 2024-01-24 15:51:59
   
## 第2章 数值与字符串

### 划线评论
- 📌 和数字一样，Python里的字符串（string）也很容易上手[插图]。它直接兼容所有的Unicode字符，处理起中文来非常方便：  ^2009032-7ItqxVOCw
    - 💭 Python 2 里面的坑还是不少的。
    - ⏱ 2023-05-25 16:28:29
   
## 2.1 基础知识

### 划线评论
- 📌 为了解决这个问题，Python提供了一个内置模块：decimal。  ^2009032-7OsA93Rvt
    - 💭 在游戏领域，有另外一种解决方案：定点数。
    - ⏱ 2024-01-24 16:29:50
   
## 4.1 基础知识

### 划线评论
- 📌 除整型外，其他内置类型的布尔值规则如下。· 布尔值为假：None、0、False、[]、()、{}、set()、frozenset()，等等。· 布尔值为真：非0的数值、True，非空的序列、元组、字典，用户定义的类和实例，等等。  ^2009032-7OEhmGyBP
    - 💭 Python的判断。
    - ⏱ 2024-02-01 09:03:08
   
## 4.3 编程建议

### 划线评论
- 📌 not A or not B等价于not (A and B)  ^2009032-7OEhZYuFO
    - 💭 本质上还是简化逻辑表达。
    - ⏱ 2024-02-01 09:12:49

### 划线评论
- 📌 or最有趣的地方是它的“短路求值”特性。  ^2009032-7OEi5GSIr
    - 💭 这里也有陷阱。如果or后面的那个表达式涉及到逻辑计算，尤其是需要更新数据的时候，这种写法就会有问题。
    - ⏱ 2024-02-01 09:14:13
   
## 5.3 编程建议

### 划线评论
- 📌 简单来说，“空对象模式”就是本该返回None值或抛出异常时，返回一个符合正常结果接口的特制“空类型对象”来代替，以此免去调用方的错误处理工作。  ^2009032-7IOiyiKiO
    - 💭 按照这个理论，其实返回空列表，空字符串，都要比None要好。因为很多的上层调用接口会默认返回的列表不是None，用for循环来读取，就会导致抛出异常。
    - ⏱ 2023-06-08 09:46:31
   
## 7.1 基础知识

### 划线评论
- 📌 当我们为函数参数设置了默认值，不强制要求调用方提供这些参数以后，会引入另一件麻烦事儿：无法严格区分调用方是不是真的提供了这个默认参数。  ^2009032-7IZfqzD5D
    - 💭 我没明白为啥要严格区分这种情况呢？
    - ⏱ 2023-06-15 14:32:10
   
# 本书评论
