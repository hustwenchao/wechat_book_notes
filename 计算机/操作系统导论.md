---
doc_type: weread-highlights-reviews
bookId: "30179184"
author: 雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔
cover: https://cdn.weread.qq.com/weread/cover/71/YueWen_30179184/t7_YueWen_30179184.jpg
reviewCount: 3
noteCount: 49
isbn: 9787115508232
category: 计算机-计算机综合
lastReadDate: 2022-10-23
---
# 元数据
> [!abstract] 操作系统导论
> - ![ 操作系统导论|200](https://cdn.weread.qq.com/weread/cover/71/YueWen_30179184/t7_YueWen_30179184.jpg)
> - 书名： 操作系统导论
> - 作者： 雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔
> - 简介： 这是一本关于现代操作系统的书。全书围绕虚拟化、并发和持久性这3个主要概念展开，介绍了所有现代系统的主要组件（包括调度、虚拟内存管理、磁盘和I/O子系统、文件系统 ）。 本书共50章，分为3个部分，分别讲述虚拟化、并发和持久性的相关内容。本书大部分章节均先提出特定的问题，然后通过书中介绍的技术、算法和思想来解决这些问题。笔者以对话形式引入所介绍的主题概念，行文诙谐幽默却又鞭辟入里，力求帮助读者理解操作系统中虚拟化、并发和持久性的原理。 本书内容全面，并给出了真实可运行的代码（而非伪代码），还提供了相应的练习，适合高等院校相关专业教师教学和高校学生自学。
> - 出版时间 2019-06-01 00:00:00
> - ISBN： 9787115508232
> - 分类： 计算机-计算机综合
> - 出版社： 人民邮电出版社

# 高亮划线

## 前言


- 📌 虚拟化（virtualization）、并发（concurrency）和持久性（persistence） ^30179184-6-620-672
    - ⏱ 2022-10-08 01:05:49 

- 📌 我们通常不使用幻灯片来讲课，但现在我们已经为那些喜欢这种演示风格的人提供了一套教学PPT ^30179184-6-2850-2894
    - ⏱ 2022-10-08 01:07:44 
## 第2章 操作系统介绍


- 📌 操作系统（Operating System，OS） ^30179184-9-1035-1095
    - ⏱ 2022-10-08 01:12:42 

- 📌 也就是说，操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机（virtual machine）。 ^30179184-9-1572-1665
    - ⏱ 2022-10-08 01:13:15 

- 📌 操作系统承担了资源管理器（resource manager）的角色。 ^30179184-9-3995-4029
    - ⏱ 2022-10-08 01:15:20 

- 📌 但实际情况是，物理内存是由操作系统管理的共享资源。 ^30179184-9-6193-6218
    - ⏱ 2022-10-08 01:16:33 

- 📌 现代多线程（multi-threaded）程序也存在相同的问题。我们来看一个多线程程序的例子 ^30179184-9-6542-6588
    - ⏱ 2022-10-08 01:16:54 

- 📌 为了使不同的通用操作更高效，文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的B树 ^30179184-9-11285-11333
    - ⏱ 2022-10-08 01:19:21 

- 📌 系统调用和过程调用之间的关键区别在于，系统调用将控制转移（跳转）到OS中，同时提高硬件特权级别（hardware privilege level） ^30179184-9-14028-14101
    - ⏱ 2022-10-08 01:21:41 
## 第4章 抽象：进程


- 📌 操作系统通过虚拟化（virtualizing）CPU来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟CPU的假象。这就是时分共享（time sharing）CPU技术，允许用户如愿运行多个并发进程。潜在的开销就是性能损失，因为如果CPU必须共享，每个进程的运行就会慢一点。 ^30179184-11-789-948
    - ⏱ 2022-10-08 20:54:10 
 

- 📌 操作系统也可能为程序的堆（heap）分配一些内存。在C程序中，堆用于显式请求的动态分配数据。程序通过调用malloc()来请求这样的空间，并通过调用free()来明确地释放它。数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。起初堆会很小。随着程序运行，通过malloc()库API请求更多内存，操作系统可能会参与分配更多内存给进程，以满足这些调用。 ^30179184-11-4424-4603
    - ⏱ 2022-10-08 21:52:52 
## 第5章 插叙：进程API


- 📌 你可能已经注意到，子进程并不是完全拷贝了父进程。具体来说，虽然它拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等，但是它从fork()返回的值是不同的。父进程获得的返回值是新创建子进程的PID，而子进程获得的返回值是0。这个差别非常重要，因为这样就很容易编写代码处理两种不同的情况（像上面那样）。 ^30179184-12-2397-2555
    - ⏱ 2022-10-08 22:02:02 
 
## 第6章 机制：受限直接执行


- 📌 第一个是性能：如何在不增加系统开销的情况下实现虚拟化？第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？ ^30179184-13-528-585
    - ⏱ 2022-10-10 12:04:17 

- 📌 受限的直接执行（limited direct execution） ^30179184-13-980-1013
    - ⏱ 2022-10-10 12:04:36 

- 📌 硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。 ^30179184-13-2176-2356
    - ⏱ 2022-10-10 12:05:38 

- 📌 为了实现这一点，几乎所有的现代硬件都提供了用户程序执行系统调用的能力。 ^30179184-13-2817-2852
    - ⏱ 2022-10-10 12:06:33 

- 📌 它允许内核小心地向用户程序暴露某些关键功能，例如访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存。 ^30179184-13-2884-2940
    - ⏱ 2022-10-10 12:06:42 

- 📌 因此，C库中进行系统调用的部分是用汇编手工编码的，因为它们需要仔细遵循约定，以便正确处理参数和返回值，以及执行硬件特定的陷阱指令。 ^30179184-13-3794-3859
    - ⏱ 2022-10-10 12:07:46 
 

- 📌 提示：利用时钟中断重新获得控制权即使进程以非协作的方式运行，添加时钟中断（timer interrupt）也让操作系统能够在CPU上重新运行。因此，该硬件功能对于帮助操作系统维持机器的控制权至关重要。 ^30179184-13-7096-7221
    - ⏱ 2022-10-10 12:14:30 

- 📌 操作系统还开发了许多复杂的加锁（locking）方案，以保护对内部数据结构的并发访问。这使得多个活动可以同时在内核中进行，特别适用于多处理器。 ^30179184-13-11003-11074
    - ⏱ 2022-10-10 12:18:54 
## 第7章 进程调度：介绍


- 📌 事实上，调度的起源早于计算机系统。早期调度策略取自于操作管理领域，并应用于计算机。 ^30179184-14-557-598
    - ⏱ 2022-10-11 00:11:51 

- 📌 任务的周转时间定义为任务完成时间减去任务到达系统的时间。 ^30179184-14-1741-1769
    - ⏱ 2022-10-11 10:36:41 

- 📌 性能和公平在调度系统中往往是矛盾的。 ^30179184-14-2181-2199
    - ⏱ 2022-10-11 10:37:00 

- 📌 更一般地说，任何公平（fair）的政策（如RR），即在小规模的时间内将CPU均匀分配到活动进程之间，在周转时间这类指标上表现不佳。事实上，这是固有的权衡：如果你愿意不公平，你可以运行较短的工作直到完成，但是要以响应时间为代价。如果你重视公平性，则响应时间会较短，但会以周转时间为代价。这种权衡在系统中很常见。你不能既拥有你的蛋糕，又吃它[3] ^30179184-14-9118-9324
    - ⏱ 2022-10-11 20:54:57 
## 第8章 调度：多级反馈队列


- 📌 看一个有I/O的例子。根据上述规则4b，如果进程在时间片用完之前主动放弃CPU，则保持它的优先级不变。这条规则的意图很简单：假设交互型工作中有大量的I/O操作（比如等待用户的键盘或鼠标输入），它会在时间片用完之前放弃CPU。在这种情况下，我们不想处罚它，只是保持它的优先级不变。 ^30179184-15-3986-4125
    - ⏱ 2022-10-11 23:15:27 
## 第12章 关于内存虚拟化的对话


- 📌 用户程序生成的每个地址都是虚拟地址（every address generated by a user program is a virtual address）。操作系统只是为每个进程提供一个假象，具体来说，就是它拥有自己的大量私有内存。在一些硬件帮助下，操作系统会将这些假的虚拟地址变成真实的物理地址，从而能够找到想要的信息。 ^30179184-19-1144-1309
    - ⏱ 2022-10-14 19:29:05 
## 第13章 抽象：地址空间


- 📌 因此操作系统需要提供一个易用（easy to use）的物理内存抽象。这个抽象叫作地址空间（address space），是运行的程序看到的系统中的内存。理解这个基本的操作系统内存抽象，是了解内存虚拟化的关键。 ^30179184-20-2318-2423
    - ⏱ 2022-10-14 19:31:22 

- 📌 当程序在运行的时候，利用栈（stack）来保存当前的函数调用信息，分配空间给局部变量，传递参数和函数返回值。最后，堆（heap）用于管理动态分配的、用户管理的内存，就像你从C语言中调用malloc()或面向对象语言（如C ++或Java）中调用new 获得内存。当然，还有其他的东西（例如，静态初始化的变量），但现在假设只有这3个部分：代码、栈和堆。 ^30179184-20-2495-2670
    - ⏱ 2022-10-14 19:32:11 

- 📌 隔离是建立可靠系统的关键原则。如果两个实体相互隔离，这意味着一个实体的失败不会影响另一个实体。操作系统力求让进程彼此隔离，从而防止相互造成伤害。通过内存隔离，操作系统进一步确保运行程序不会影响底层操作系统的操作。一些现代操作系统通过将某些部分与操作系统的其他部分分离，实现进一步的隔离。这样的微内核（microkernel）[BH70，R+89，S+03] 可以比整体内核提供更大的可靠性。 ^30179184-20-3998-4193
    - ⏱ 2022-10-14 19:34:17 

- 📌 我们介绍了操作系统的一个重要子系统：虚拟内存。虚拟内存系统负责为程序提供一个巨大的、稀疏的、私有的地址空间的假象，其中保存了程序的所有指令和数据。操作系统在专门硬件的帮助下，通过每一个虚拟内存的索引，将其转换为物理地址，物理内存根据获得的物理地址去获取所需的信息。 ^30179184-20-6338-6470
    - ⏱ 2022-10-14 19:36:44 
## 第14章 插叙：内存操作API


- 📌 第一种称为栈（stack）内存，它的申请和释放操作是编译器来隐式管理的，所以有时也称为自动（automatic）内存。 ^30179184-21-747-806
    - ⏱ 2022-10-14 19:37:53 

- 📌 就是这种对长期内存的需求，所以我们才需要第二种类型的内存，即所谓的堆（heap）内存，其中所有的申请和释放操作都由程序员显式地完成。 ^30179184-21-1093-1159
    - ⏱ 2022-10-14 19:38:09 

- 📌 出于这个原因，sizeof() 被正确地认为是一个操作符，而不是一个函数调用（函数调用在运行时发生）。 ^30179184-21-2567-2618
    - ⏱ 2022-10-14 19:39:34 
## 第15章 机制：地址转换


- 📌 基于硬件的地址转换（hardware-based address translation），简称为地址转换（address translation） ^30179184-22-1069-1143
    - ⏱ 2022-10-14 19:46:27 

- 📌 介入是一种很常见又很有用的技术，计算机系统中使用介入常常能带来很好的效果。在虚拟内存中，硬件可以介入到每次内存访问中，将进程提供的虚拟地址转换为数据实际存储的物理地址。但是，一般化的介入技术有更广阔的应用空间，实际上几乎所有良好定义的接口都应该提供功能介入机制，以便增加功能或者在其他方面提升系统。这种方式最基本的优点是透明（transparency），介入完成时通常不需要改动接口的客户端，因此客户端不需要任何改动。 ^30179184-22-2701-2910
    - ⏱ 2022-10-14 19:52:00 

- 📌 基址加界限机制（base and bound），有时又称为动态重定位（dynamic relocation），我们将互换使用这两个术语 ^30179184-22-4350-4417
    - ⏱ 2022-10-14 20:00:28 

- 📌 具体来说，每个CPU需要两个硬件寄存器：基址（base）寄存器和界限（bound）寄存器，有时称为限制（limit）寄存器。这组基址和界限寄存器，让我们能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间。 ^30179184-22-4437-4552
    - ⏱ 2022-10-14 20:01:46 

- 📌 界限寄存器的用处在于，它确保了进程产生的所有地址都在进程的地址“界限”中。 ^30179184-22-6188-6225
    - ⏱ 2022-10-14 20:04:47 
## 第16章 分段


- 📌 分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。 ^30179184-23-1120-1175
    - ⏱ 2022-10-15 20:21:12 

- 📌 这就是每个C程序员都感到恐慌的术语的来源：段异常（segmentation violation）或段错误（segmentation fault）。 ^30179184-23-2858-2931
    - ⏱ 2022-10-15 22:47:02 

- 📌 尤其是，代码共享很常见，今天的系统仍然在使用。 ^30179184-23-5669-5692
    - ⏱ 2022-10-15 22:50:36 

- 📌 为了支持共享，需要一些额外的硬件支持，这就是保护位（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。 ^30179184-23-5705-5871
    - ⏱ 2022-10-15 22:50:47 

- 📌 但是，内存紧凑成本很高，因为拷贝段是内存密集型的，一般会占用大量的处理器时间。 ^30179184-23-7845-7884
    - ⏱ 2022-10-15 22:55:37 

- 📌 一种更简单的做法是利用空闲列表管理算法，试图保留大的内存块用于分配。相关的算法可能有成百上千种，包括传统的最优匹配（best-fit，从空闲链表中找最接近需要分配空间的空闲块返回）、最坏匹配（worst-fit）、首次匹配（first-fit）以及像伙伴算法（buddy algorithm）[K68]这样更复杂的算法。Wilson等人做过一个很好的调查[W+95]，如果你想对这些算法了解更多，可以从它开始，或者等到第17 章，我们将介绍一些基本知识。但遗憾的是，无论算法多么精妙，都无法完全消除外部碎片，因此，好的算法只是试图减小它。 ^30179184-23-7916-8185
    - ⏱ 2022-10-15 22:55:48 
## 第18章 分页：介绍


- 📌 通过完善的分页方法，操作系统能够高效地提供地址空间的抽象，不管进程如何使用地址空间。例如，我们不会假定堆和栈的增长方向，以及它们如何使用 ^30179184-25-1551-1619
    - ⏱ 2022-10-20 12:42:53 
## 第19章 分页：快速地址转换（TLB）


- 📌 地址转换旁路缓冲存储器（translation-lookaside buffer，TLB[CG68,C95]） ^30179184-26-778-833
    - ⏱ 2022-10-23 00:51:23 
# 读书笔记

## 第4章 抽象：进程

### 划线评论
- 📌 将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操作。必须为程序的运行时栈（run-time stack或stack）分配一些内存。你可能已经知道，C程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。操作系统也可能会用参数初始化栈。具体来说，它会将参数填入main()函数，即argc和argv数组。  ^2009032-7CRqUPU9w
    - 💭 栈的概念：C语言用栈来存放局部变量、函数参数和返回地址。
    - ⏱ 2022-10-08 21:52:46
   
## 第5章 插叙：进程API

### 划线评论
- 📌 最后，阅读man手册可以避免尴尬。当你询问同事某个fork细节时，他可能会回复：“RTFM”。这是他在有礼貌地督促你阅读man手册（Read the Man）。RTFM中的F只是为这个短语增加了一点色彩……  ^2009032-7CRrOm9Lk
    - 💭 盲猜 Read The Fucking Man。哈哈哈
    - ⏱ 2022-10-08 22:06:26
   
## 第6章 机制：受限直接执行

### 划线评论
- 📌 LDE  ^2009032-7CTRxUO35
    - 💭 Limited Direct Execution
    - ⏱ 2022-10-10 12:12:43
   
# 本书评论
